<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5.js Fjärilssvärm Boids</title>
    <!-- Laddar in Tailwind CSS för enklare layout och responsivitet (används fortfarande för bakgrund/body-stil) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Laddar in p5.js biblioteket -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        /* Sätter HTML och Body till full höjd och bredd för att fylla webbläsaren */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Förhindrar scrollning */
            height: 100%;
        }
        /* Säkerställer att p5.js canvas fyller sin container */
        canvas {
            display: block;
            touch-action: none; /* Viktigt för att förhindra standard touch-gesturer (zoom/scroll) i Chrome på Android */
        }
    </style>
</head>
<body class="bg-[#f7f7f7] antialiased flex items-center justify-center h-screen w-screen">

    <script>
        // Globala konstanter för fjärilens gemensamma utseende/gränser
        const BUTTERFLY_COUNT = 20;       
        const INITIAL_V_ANGLE = Math.PI / 6; 
        const FLAP_AMPLITUDE = Math.PI / 8; 
        const SCATTER_RADIUS = 15;        
        
        // FÄRG PALETT
        const COLOR_PALETTE = [
            '#4CAF50', // Grön
            '#FFC107', // Gul
            '#64B5F6', // Ljusblå
            '#3F51B5', // Marinblå
            '#FF6361'  // Korall/Röd
        ];

        // --- Boid / Flockningskonstanter ---
        const MAX_FORCE = 0.02;   
        const PERCEPTION_RADIUS = 80; 
        const SEPARATION_DISTANCE = 30; 
        const NOISE_WEIGHT = 0.4;    
        const COHESION_WEIGHT = 1.0; 
        const ALIGNMENT_WEIGHT = 0.4; 
        const SEPARATION_WEIGHT = 3.0; 

        // --- Mål/Landningskonstanter ---
        const SCARE_DURATION_MS = 4000; // 4 sekunder som fjärilarna flyr/flyger i flock efter musrörelse
        
        // --- NYA TRÄD/FALL KONSTANTER ---
        const MAX_BUTTERFLIES_PER_BRANCH = 8;        // Maximal last innan grenen faller
        const FALL_FLIGHT_DURATION_MS = 8000;         // 8 sekunder flygtid efter fall
        // Djup 1 är nu den första nivån som kan falla och ta emot fjärilar. Djup 0 är permanent.
        const OUTER_BRANCH_DEPTH_START = 1;           
        
        // --- VISUELL FALLKONSTANTER ---
        const FALL_ANIMATION_DURATION_MS = 1500;      // Tid för fallanimation
        const FALL_GRAVITY = 0.5;                     // Visuell "gravitation" för fallet (högre = snabbare)

        // Fractal Tree konstanter
        const MAX_DEPTH = 4;           
        const INITIAL_LENGTH = 100;    
        const BRANCH_ANGLE = Math.PI / 6; 
        const MAX_ANIMATION_TIME_MS = 5000; 

        const SCARE_RADIUS = 40;       

        let canvas;
        let butterflies = []; 
        let lastClickTime; 
        let segmentIdCounter = 0; // Räknare för unika segment-ID

        // Variabler för träd och animation
        let treeLandingSpots = []; // Lagrar: { spot: p5.Vector, segmentId: number }
        let treeSegments = [];     // Lagrar TreeSegment-objekt
        let treeDrawn = false;     
        let treeAnimationStartTime = 0; 
        let currentFallDepth = MAX_DEPTH; 
        
        // --- P5.JS KNAPP-KONSTANTER ---
        const BUTTON_SIZE = 24;
        const BUTTON_PADDING = 16;
        const BUTTON_START_X = 80;
        const BUTTON_START_Y = 20;

        // Definierar knapparnas positioner (inuti P5.js canvas)
        const BUTTONS = {
            TREE: {
                x: BUTTON_START_X,
                y: BUTTON_START_Y,
                w: BUTTON_SIZE,
                h: BUTTON_SIZE
            },
            CLEAR: {
                x: BUTTON_START_X + BUTTON_SIZE + BUTTON_PADDING, 
                y: BUTTON_START_Y,
                w: BUTTON_SIZE,
                h: BUTTON_SIZE
            }
        };


        /**
         * Klass för att representera ett enda linjesegment i trädet med last- och fallstatus.
         */
        class TreeSegment {
            constructor(start, end, isOuter, id, depth) {
                this.start = start;
                this.end = end;
                this.isOuter = isOuter; 
                this.isFallen = false;  
                this.isFalling = false; 
                this.fallStartTime = 0; 
                this.load = 0;          
                this.id = id;           
                this.landingSpots = []; 
                this.depth = depth;     
            }
        }

        /**
         * Klass för att representera en enskild fjäril (Boid).
         */
        class Butterfly {
            constructor(x, y, isAttractionActiveOnPress = false) { 
                this.position = createVector(x, y);
                this.velocity = p5.Vector.random2D(); 
                this.velocity.setMag(random(1.0, 1.8)); 
                this.acceleration = createVector(0, 0);
                
                this.wingLength = random(5, 10); 
                // ÄNDRAT: Fast vingbredd på 1px för visuellt test
                this.strokeWeight = 1; 
                this.color = random(COLOR_PALETTE); 
                
                this.flapOffset = random(0, TWO_PI);
                this.noiseOffset = random(1000);
                
                this.maxSpeed = random(1.0, 1.8);          
                this.flapSpeed = random(0.1, 0.35);        
                this.verticalStudScale = random(3, 8);     
                this.noiseScale = random(0.02, 0.035);    

                // --- Landningsstatus ---
                this.isLanded = false;
                this.targetSpot = null; 
                this.parentSegmentId = null; 
                
                // Timers
                this.scareTimer = 0;        
                this.fallFlightTimer = 0;   
                
                if (isAttractionActiveOnPress) {
                    this.scareTimer = millis() + SCARE_DURATION_MS;
                }
            }
            
            /** Hjälpfunktion för att hitta segmentobjektet utifrån ID. */
            findSegment(segmentId) {
                return treeSegments.find(s => s.id === segmentId);
            }
            
            /** Initierar lyft från marken eller gren. */
            liftOff(isFall = false) {
                // 1. Minska lasten på den gamla grenen (om landad)
                if (this.isLanded && this.parentSegmentId !== null) {
                    const segment = this.findSegment(this.parentSegmentId);
                    if (segment) {
                        segment.load--;
                    }
                }
                
                // 2. Återställ status
                this.isLanded = false;
                this.targetSpot = null; 
                this.parentSegmentId = null;
                this.acceleration.mult(0); 

                // 3. Sätt flygtimer
                if (isFall) {
                    this.fallFlightTimer = millis() + FALL_FLIGHT_DURATION_MS;
                } else {
                    this.scareTimer = millis() + SCARE_DURATION_MS;
                }
                
                // 4. Ge den en initial hastighet
                this.velocity = p5.Vector.random2D().setMag(this.maxSpeed * 1.5);
            }

            /** Applicerar en kraft på fjärilens acceleration. */
            applyForce(force) {
                this.acceleration.add(force);
            }

            /** Beräknar en styrkraft för att flyga mot en given vektor. */
            seek(target) {
                let desired = p5.Vector.sub(target, this.position);
                desired.setMag(this.maxSpeed);
                let steer = p5.Vector.sub(desired, this.velocity);
                steer.limit(MAX_FORCE);
                return steer;
            }

            /** --- Boid Rule 1: Separation --- */
            separate(butterflies) {
                let steering = createVector(0, 0);
                let total = 0;
                
                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < SEPARATION_DISTANCE) {
                        let diff = p5.Vector.sub(this.position, other.position);
                        diff.normalize(); 
                        diff.div(d);     
                        steering.add(diff);
                        total++;
                    }
                }
                
                if (total > 0) {
                    steering.div(total); 
                    steering.setMag(this.maxSpeed); 
                    steering.sub(this.velocity); 
                    steering.limit(MAX_FORCE);
                }
                return steering;
            }

            /** --- Boid Rule 2: Alignment --- */
            align(butterflies) {
                let sum = createVector(0, 0);
                let count = 0;
                
                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < PERCEPTION_RADIUS) {
                        sum.add(other.velocity);
                        count++;
                    }
                }

                if (count > 0) {
                    sum.div(count); 
                    sum.setMag(this.maxSpeed);
                    let steer = p5.Vector.sub(sum, this.velocity);
                    steer.limit(MAX_FORCE);
                    return steer;
                }
                return createVector(0, 0);
            }

            /** --- Boid Rule 3: Cohesion --- */
            cohere(butterflies) {
                let centerOfMass = createVector(0, 0);
                let count = 0;

                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < PERCEPTION_RADIUS) {
                        centerOfMass.add(other.position);
                        count++;
                    }
                }

                if (count > 0) {
                    centerOfMass.div(count); 
                    return this.seek(centerOfMass); 
                }
                return createVector(0, 0);
            }

            /** Beräknar en drivkraft från Perlin Noise. */
            calculateNoiseForce() {
                let angle = noise(this.noiseOffset, frameCount * this.noiseScale) * TWO_PI * 4; 
                let noiseVector = p5.Vector.fromAngle(angle);
                
                let steering = p5.Vector.sub(noiseVector.setMag(this.maxSpeed), this.velocity);
                steering.limit(MAX_FORCE); 
                steering.mult(NOISE_WEIGHT); 
                return steering;
            }
            
            /** Styr fjärilen mot trädets landningsplatser. */
            approachTarget() {
                // 1. Hitta en målposition/segment om ingen finns
                if (this.targetSpot === null || this.parentSegmentId === null) {
                    if (treeLandingSpots.length > 0) {
                        // Filtrera bort platser som tillhör fallna eller fallande grenar
                        const availableSpots = treeLandingSpots.filter(s => {
                            const segment = this.findSegment(s.segmentId);
                            // Endast landa på segment som inte är fallna OCH inte faller
                            return segment && !segment.isFallen && !segment.isFalling;
                        });
                        
                        if (availableSpots.length === 0) return; // Inga lediga platser
                        
                        // Väljer plats slumpmässigt bland de tillgängliga
                        const selected = random(availableSpots);
                        this.targetSpot = selected.spot;
                        this.parentSegmentId = selected.segmentId;
                    } else {
                        // Inga landningsplatser i trädet, fjärilen fortsätter flyga (Boids-beteende)
                        return;
                    }
                }
                
                // 2. Kontrollera om nuvarande målsegment har fallit under flygning
                const currentSegment = this.findSegment(this.parentSegmentId);
                if (!currentSegment || currentSegment.isFallen || currentSegment.isFalling) {
                    this.targetSpot = null;
                    this.parentSegmentId = null;
                    return; // Uppdatera på nytt för att hitta nytt mål eller återgå till flock
                }
                
                let targetPoint = this.targetSpot;

                // 3. Beräkna avståndet till målet
                let distToTarget = p5.Vector.dist(this.position, targetPoint);

                // 4. Landningscheck
                if (distToTarget < 5) { 
                    if (!this.isLanded) { // Endast räkna last en gång vid landning
                        this.isLanded = true;
                        this.position = targetPoint.copy().add(random(-3, 3), random(-3, 3)); 
                        this.velocity.mult(0); 
                        this.acceleration.mult(0);
                        
                        // Öka lasten på målsegmentet
                        currentSegment.load++;
                    }
                } else {
                    // 5. Styr mot målet
                    let steer = this.seek(targetPoint);
                    this.applyForce(steer.mult(1.5)); 
                }
            }


            /** Sammanställer och applicerar alla Boid-regler. */
            flock(butterflies) {
                let separation = this.separate(butterflies);
                let alignment = this.align(butterflies);
                let cohesion = this.cohere(butterflies);

                // Applicera vikt (styrka) på krafterna
                separation.mult(SEPARATION_WEIGHT);
                alignment.mult(ALIGNMENT_WEIGHT);
                cohesion.mult(COHESION_WEIGHT);

                // Lägg till krafterna
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }

            /**
             * Uppdaterar fjärilens position.
             */
            update(butterflies, isAttractionActive) {
                
                // 1. Kontrollera om fjärilen flyger p.g.a. grenfall (8s flygning)
                if (this.fallFlightTimer > 0 && millis() < this.fallFlightTimer) {
                    // Fortsätt flyga som Boid
                    this.flock(butterflies); 
                    let noiseForce = this.calculateNoiseForce();
                    this.applyForce(noiseForce);
                } else if (this.fallFlightTimer > 0 && millis() >= this.fallFlightTimer) {
                    // 8 sekunder har passerat, återställ timern och sök nytt mål
                    this.fallFlightTimer = 0;
                    this.targetSpot = null;
                    this.parentSegmentId = null;
                }
                
                // 2. Kontrollera om landad (och om grenen har fallit/håller på att falla)
                if (this.isLanded) {
                    const segment = this.findSegment(this.parentSegmentId);
                    // Om segmentet inte finns, eller är fallit/faller, lyft omedelbart
                    if (!segment || segment.isFallen || segment.isFalling) {
                        this.liftOff(true); // Grenen föll, lyft och flyg i 8s
                    }
                    return; // Stoppa uppdatering om landad och grenen är stabil
                }
                
                // 3. Om inte i fall-flygning eller landad, använd normal logik
                const isScared = millis() < this.scareTimer; 

                if (isAttractionActive && !isScared && this.fallFlightTimer === 0) {
                    this.approachTarget(); 
                } else if (this.fallFlightTimer === 0) {
                    // Normal Boids flocking/scare flight
                    this.flock(butterflies); 
                    let noiseForce = this.calculateNoiseForce();
                    this.applyForce(noiseForce);
                }

                // 4. Tillämpa fysik
                this.velocity.add(this.acceleration);
                this.velocity.limit(this.maxSpeed);
                this.position.add(this.velocity);
                
                // 5. Nollställ accelerationen
                this.acceleration.mult(0); 

                // 6. Wrap-around (Gränshantering)
                if (this.position.x < 0) this.position.x = width;
                if (this.position.x > width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = height;
                if (this.position.y > height) this.position.y = 0;
            }

            /**
             * Ritar fjärilen på canvasen och animerar dess flax och studs.
             */
            display() {
                let flap = sin(frameCount * this.flapSpeed + this.flapOffset) * FLAP_AMPLITUDE;
                let yOffset = -flap * this.verticalStudScale; 
                
                push();
                
                translate(this.position.x, this.position.y + yOffset);
                
                // TILT-LOGIK
                const MAX_TILT_RAD = QUARTER_PI; 
                let normalizedX = constrain(this.velocity.x / this.maxSpeed, -1, 1); 
                let tiltAngle = normalizedX * MAX_TILT_RAD;
                rotate(tiltAngle); 
                
                stroke(this.color); 
                // Använder den fasta tjockleken (1) från konstruktorn
                strokeWeight(this.strokeWeight); 
                noFill();

                // Vingar
                push();
                rotate(-INITIAL_V_ANGLE - flap);
                line(0, 0, 0, -this.wingLength); 
                pop();

                push();
                rotate(INITIAL_V_ANGLE + flap);
                line(0, 0, 0, -this.wingLength);
                pop();

                pop();
            }
        }
        
        // --- Fraktal Träd Logik ---
        
        /**
         * Rekursiv funktion för att generera alla trädsegment och lagra dem.
         */
        function generateBranch(startPos, len, angle, depth) {
            if (depth > MAX_DEPTH) return;

            let dx = len * sin(angle);
            let dy = len * cos(angle);
            
            let endPos = createVector(startPos.x + dx, startPos.y - dy); 

            // isOuter är nu true från och med djup 1 (Djup 0 är permanent stam)
            const isOuter = depth >= OUTER_BRANCH_DEPTH_START; 
            const newSegment = new TreeSegment(startPos.copy(), endPos.copy(), isOuter, segmentIdCounter++, depth);
            treeSegments.push(newSegment);

            // Skapa landningsfläckar och koppla dem till detta segment
            const numSamples = 4;
            // Landningsfläckar skapas från och med djup 1
            if (depth >= OUTER_BRANCH_DEPTH_START) { 
                for (let i = 1; i < numSamples; i++) {
                    let t = i / numSamples;
                    let spot = p5.Vector.lerp(startPos, endPos, t);
                    newSegment.landingSpots.push(spot);
                    treeLandingSpots.push({ spot: spot, segmentId: newSegment.id }); 
                }
            }
            
            // Slutpunkten för de djupaste grenarna (MAX_DEPTH) är också landningsplatser
            if (depth === MAX_DEPTH) {
                newSegment.landingSpots.push(endPos.copy());
                treeLandingSpots.push({ spot: endPos.copy(), segmentId: newSegment.id });
            }


            if (depth < MAX_DEPTH) {
                let nextLen = len * 0.7;

                generateBranch(endPos, nextLen, angle - BRANCH_ANGLE, depth + 1);
                generateBranch(endPos, nextLen, angle + BRANCH_ANGLE, depth + 1);
            }
        }

        /**
         * Funktion för att förberäkna alla trädsegment.
         */
        function precalculateTree() {
            treeSegments = [];
            treeLandingSpots = [];
            segmentIdCounter = 0; // Återställ ID-räknaren
            
            const startPos = createVector(width / 2, height);
            
            // Återställ den nuvarande falldjupet till max
            currentFallDepth = MAX_DEPTH; 
            
            generateBranch(startPos, INITIAL_LENGTH, 0, 0); 
        }

        /**
         * Ritar trädets segment baserat på animationens framsteg och hanterar fallanimation.
         */
        function drawAnimatedTree(progress) {
            if (treeSegments.length === 0) return;

            stroke('#333');
            // Enhetlig tjocklek på 1px för alla grenar.
            strokeWeight(1); 
            noFill();

            const totalSegments = treeSegments.length;
            const segmentsToDraw = progress * totalSegments;

            const fullSegments = floor(segmentsToDraw);
            
            for (let i = 0; i < totalSegments; i++) {
                const seg = treeSegments[i];
                
                // 1. Hoppa över helt fallna grenar
                if (seg.isFallen) continue;
                
                let start = seg.start;
                let end = seg.end;
                
                // Sätter tjocklek (den är nu alltid 1 här)
                strokeWeight(1);
                
                // 2. Hantera fallande grenar (visuell animation)
                if (seg.isFalling) {
                    const timeElapsed = millis() - seg.fallStartTime;
                    
                    if (timeElapsed < FALL_ANIMATION_DURATION_MS) {
                        const t = timeElapsed / 1000; // Tid i sekunder
                        
                        // Enkel fallsimulering (gravitation)
                        let fallDistance = FALL_GRAVITY * t * t * 1000; 
                        // Lite sidodrift baserat på grenens lutning
                        let sideDrift = (seg.end.x - seg.start.x > 0) ? t * 50 : -t * 50; 
                        
                        // Applicera fall-transformation på segmentets positioner
                        start = start.copy().add(sideDrift, fallDistance);
                        end = end.copy().add(sideDrift, fallDistance);

                    } else {
                        // Animation klar, markera som helt borta
                        seg.isFalling = false;
                        seg.isFallen = true;
                        continue;
                    }
                }
                
                // 3. Ritmoment (inklusive tillväxtanimation)
                if (i < fullSegments) {
                    // Helt ritat segment (eller fallande, där start/end är modifierade)
                    line(start.x, start.y, end.x, end.y);
                } else if (!seg.isFalling && i === fullSegments && segmentsToDraw < totalSegments) {
                    // Delvis ritat segment (endast om animationen inte är klar OCH grenen inte faller)
                    const partialProgress = segmentsToDraw - fullSegments; 
                    const partialEnd = p5.Vector.lerp(start, end, partialProgress);
                    line(start.x, start.y, partialEnd.x, partialEnd.y);
                }
            }
        }
        
        /**
         * Växlar (toggle) trädets synlighet och startar/stoppar fjärilarnas landning.
         */
        function toggleTree() {
            if (treeDrawn) {
                // Träd finns: Ta bort det
                treeDrawn = false; 
                treeSegments = [];
                treeLandingSpots = []; 
                treeAnimationStartTime = 0;
                lastClickTime = millis(); 
                currentFallDepth = MAX_DEPTH; // Återställ vid borttagning
                
                // Fjärilarna lyfter
                for (let b of butterflies) {
                    b.liftOff(false); // Normal lift-off (4s scare)
                }

            } else {
                // Träd finns inte: Skapa det
                precalculateTree();
                treeAnimationStartTime = millis();
                treeDrawn = true; 
                lastClickTime = millis(); 
                
                // Fjärilarna lyfter för att flyga fritt tills trädet är klart
                for (let b of butterflies) {
                    b.isLanded = false;
                    b.targetSpot = null; 
                }
            }
        }
        
        /**
         * Ritar de två in-sketch-knapparna (Tree och Clear) med den nya stilen.
         */
        function drawButtons() {
            // Färg för 50% opacitet svart (51, 51, 51, 128)
            const HALF_ALPHA_COLOR = color(51, 51, 51, 128); 

            // Ritar knapparna
            for (let key in BUTTONS) {
                const btn = BUTTONS[key];
                
                push();
                
                // 1. RITA RAMEN (50% opacitet)
                stroke(HALF_ALPHA_COLOR); 
                strokeWeight(1); // 1px kantlinje
                
                // Ingen fyllning för någon av knapparna
                noFill(); 
                
                // Rita den 24x24 stora knappen med rundade hörn
                rect(btn.x, btn.y, btn.w, btn.h, 4); 

                // Ritar symbolerna (nu 10x10, centrerade)
                
                const iconSize = 10;
                const iconPadding = (btn.w - iconSize) / 2; 
                
                const iconXStart = btn.x + iconPadding; 
                const iconYStart = btn.y + iconPadding; 
                const iconXEnd = btn.x + btn.w - iconPadding; 
                const iconYEnd = btn.y + btn.h - iconPadding; 
                const iconCenterX = btn.x + btn.w / 2; 
                
                if (key === 'TREE') {
                    // Symbol: Ett enkelt träd (stam och en triangel)
                    
                    // 2. STAM (50% opacitet)
                    stroke(HALF_ALPHA_COLOR);
                    strokeWeight(1.5);
                    
                    // Stam (från ca 60% till 95% av ikonområdet)
                    line(iconCenterX, iconYStart + iconSize * 0.6, iconCenterX, iconYEnd - 1); 
                    
                    // 3. KRONA (50% opacitet)
                    noStroke();
                    fill(HALF_ALPHA_COLOR);
                    // Krona (Triangel, tar upp toppen av ikonområdet)
                    triangle(
                        iconXStart, iconYEnd - iconSize * 0.4, 
                        iconXEnd, iconYEnd - iconSize * 0.4,   
                        iconCenterX, iconYStart + 1            
                    );
                    
                } else { // CLEAR
                    // Symbol: Ett enkelt X (10x10, fyller ikonområdet)
                    
                    // 2. KRYSS (50% opacitet)
                    stroke(HALF_ALPHA_COLOR);
                    strokeWeight(1.5);
                    
                    // Linjer (diagonaler)
                    line(iconXStart, iconYStart, iconXEnd, iconYEnd);       
                    line(iconXEnd, iconYStart, iconXStart, iconYEnd);       
                }
                
                pop();
            }
        }
        
        /**
         * Kontrollerar om mus/touch klickade på en av knapparna.
         * @returns {boolean} True om en knapp klickades, annars False.
         */
        function checkButtonClicks() {
            for (let key in BUTTONS) {
                const btn = BUTTONS[key];
                
                // Kontrollerar om musX/musY är inom knappens gränser
                if (mouseX >= btn.x && mouseX <= btn.x + btn.w &&
                    mouseY >= btn.y && mouseY <= btn.y + btn.h) {
                    
                    if (key === 'TREE') {
                        toggleTree();
                    } else if (key === 'CLEAR') {
                        // Clear-logiken
                        butterflies = []; 
                        lastClickTime = millis(); 
                        treeDrawn = false; 
                        treeSegments = [];
                        treeLandingSpots = []; 
                        treeAnimationStartTime = 0; 
                        segmentIdCounter = 0;
                        currentFallDepth = MAX_DEPTH; 
                        if (canvas) {
                            background('#f7f7f7'); 
                        }
                    }
                    return true; // En knapp klickades
                }
            }
            return false; // Ingen knapp klickades
        }

        /**
         * Kontrollerar om någon gren vid det nuvarande djupet har överskridit lastgränsen och får den att falla.
         * Hanterar även kaskadeffekten.
         */
        function checkBranchFalls() {
            // Endast grenar på currentFallDepth kan utlösas att falla (dvs. currentFallDepth >= 1)
            if (currentFallDepth < OUTER_BRANCH_DEPTH_START) return;

            const newlyFallingSegmentIds = [];

            // 1. Kontrollera överbelastning vid currentFallDepth
            for (let segment of treeSegments) {
                if (segment.depth === currentFallDepth && 
                    !segment.isFallen && 
                    !segment.isFalling && 
                    segment.load > MAX_BUTTERFLIES_PER_BRANCH) 
                {
                    // Trigger fall animation
                    segment.isFalling = true;
                    segment.fallStartTime = millis();
                    newlyFallingSegmentIds.push(segment.id);
                }
            }

            // 2. Fjärilarna på de fallande segmenten lyfter
            if (newlyFallingSegmentIds.length > 0) {
                for (let b of butterflies) {
                    // liftOff kommer att hantera lastminskning och timer-sättning
                    if (newlyFallingSegmentIds.includes(b.parentSegmentId)) {
                        b.liftOff(true); // Lyft och flyg i 8s
                    }
                }
            }
            
            // 3. Kaskad-djup uppdatering
            const standingSegments = treeSegments.filter(s => 
                s.depth === currentFallDepth && !s.isFallen && !s.isFalling
            );

            // Gå inåt ENDAST om alla grenar på nuvarande djup har fallit OCH vi inte har nått det permanenta inre djupet (0)
            if (standingSegments.length === 0 && currentFallDepth > 1) {
                currentFallDepth--;
            }
        }


        // --- P5.js Standardfunktioner ---

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight);
            canvas.style('display', 'block');
            background('#f7f7f7'); 
            lastClickTime = millis(); 
        }

        function draw() {
            background('#f7f7f7'); 

            let isAttractionActive = false;
            
            if (treeDrawn) { 
                
                const isAttractionFullyActive = (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS);

                const elapsedTime = millis() - treeAnimationStartTime;
                let treeProgress = constrain(elapsedTime / MAX_ANIMATION_TIME_MS, 0, 1);
                
                // Ritar och animerar fallet
                drawAnimatedTree(treeProgress);

                if (treeProgress >= 1.0) {
                    isAttractionActive = true;
                }
            }
            
            // Kolla om grenar faller (endast när trädet är helt ritat)
            if (treeDrawn && isAttractionActive) {
                checkBranchFalls();
            }
            
            for (let butterfly of butterflies) {
                butterfly.update(butterflies, isAttractionActive); 
                butterfly.display();
            }
            
            // Ritar knapparna OVANPÅ allt annat
            drawButtons();
        }

        // ------------------------------------------------------------------
        // NY LOGIK FÖR SKRÄMSELT PÅ BÅDE MUS OCH TOUCH
        // ------------------------------------------------------------------

        /**
         * Generell funktion för att skrämma fjärilar runt en given koordinat (x, y).
         * Används av både mouseMoved och touchMoved.
         */
        function scareButterflies(x, y) {
            const isAttractionActive = (treeDrawn && (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS));

            if (isAttractionActive) {
                const checkPos = createVector(x, y);
                
                for (let b of butterflies) {
                    if (b.isLanded) {
                        let d = p5.Vector.dist(checkPos, b.position);

                        if (d < SCARE_RADIUS) {
                            b.liftOff(false); // Normal lift-off (4s scare)
                            
                            let escapeVector = p5.Vector.sub(b.position, checkPos);
                            escapeVector.normalize();
                            
                            b.velocity = escapeVector.copy().mult(b.maxSpeed * 4.0); 
                            b.applyForce(escapeVector.mult(2.0));                     
                        }
                    }
                }
            }
        }

        /**
         * Hanterar musrörelser (Desktop).
         */
        function mouseMoved() {
            scareButterflies(mouseX, mouseY);
            return false; 
        }

        /**
         * Hanterar swipe/touch rörelser (Mobil).
         * P5.js ger oss 'touches' arrayen med touch-punkter.
         */
        function touchMoved() {
            // Iterera över alla aktiva touch-punkter
            for (let touch of touches) {
                scareButterflies(touch.x, touch.y);
            }
            // Returnera false för att förhindra standardfunktioner som skrollning/zoom
            return false;
        }

        // ------------------------------------------------------------------

        /**
         * Skapar fjärilar ELLER triggar en knappklick.
         */
        function mousePressed() {
            // 1. Kontrollera om en knapp klickades
            if (checkButtonClicks()) {
                // Om en knapp klickades, stoppa exekveringen HÄR för att undvika att skapa fjärilar.
                return false; 
            }

            // 2. Om ingen knapp klickades, skapa fjärilar (gammal logik)
            const isAttractionActiveOnPress = (treeDrawn && (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS));

            for (let i = 0; i < BUTTERFLY_COUNT; i++) {
                let offsetX = random(-SCATTER_RADIUS, SCATTER_RADIUS);
                let offsetY = random(-SCATTER_RADIUS, SCATTER_RADIUS);
                
                let startX = mouseX + offsetX;
                let startY = mouseY + offsetY;
                
                let newButterfly = new Butterfly(startX, startY, isAttractionActiveOnPress);
                butterflies.push(newButterfly);
            }
            return false; 
        }
        

        // Hanterar responsivitet: Ändra canvasstorleken när fönstret ändras
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            if(treeDrawn) {
                // Återberäkna trädet baserat på den nya storleken
                precalculateTree(); 
            }
        }
    </script>
</body>
</html>
