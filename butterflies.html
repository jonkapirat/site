<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5.js Fjärilssvärm Boids</title>
    <!-- Laddar in Tailwind CSS för enklare layout och responsivitet (används fortfarande för bakgrund/body-stil) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Laddar in p5.js biblioteket -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        /* Sätter HTML och Body till full höjd och bredd för att fylla webbläsaren */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Förhindrar scrollning */
            height: 100%;
            /* Tar bort cursor: pointer; från body eftersom vi hanterar det i P5.js nu */
        }
        /* Säkerställer att p5.js canvas fyller sin container */
        canvas {
            display: block;
            /* Nu ritas allt (inklusive knappar) inuti canvasen, så inga HTML-element ligger ovanpå */
            touch-action: none; /* Viktigt för att förhindra standard touch-gesturer i Chrome på Android */
        }
    </style>
</head>
<body class="bg-[#f7f7f7] antialiased flex items-center justify-center h-screen w-screen">
    <!-- Knapparna är nu borttagna härifrån och ritas istället i P5.js -->

    <script>
        // Globala konstanter för fjärilens gemensamma utseende/gränser
        const BUTTERFLY_COUNT = 20;       
        const INITIAL_V_ANGLE = Math.PI / 6; 
        const FLAP_AMPLITUDE = Math.PI / 8; 
        const SCATTER_RADIUS = 15;        
        
        // FÄRG PALETT
        const COLOR_PALETTE = [
            '#4CAF50', // Grön
            '#FFC107', // Gul
            '#64B5F6', // Ljusblå
            '#3F51B5', // Marinblå
            '#FF6361'  // Korall/Röd
        ];

        // --- Boid / Flockningskonstanter ---
        const MAX_FORCE = 0.02;   
        const PERCEPTION_RADIUS = 80; 
        const SEPARATION_DISTANCE = 30; 
        const NOISE_WEIGHT = 0.4;    
        const COHESION_WEIGHT = 1.0; 
        const ALIGNMENT_WEIGHT = 0.4; 
        const SEPARATION_WEIGHT = 3.0; 

        // --- Mål/Landningskonstanter ---
        const SCARE_DURATION_MS = 4000; // 4 sekunder som fjärilarna flyr/flyger i flock innan de återvänder
        
        // Fractal Tree konstanter
        const MAX_DEPTH = 4;           
        const INITIAL_LENGTH = 100;    
        const BRANCH_ANGLE = Math.PI / 6; 
        const MAX_ANIMATION_TIME_MS = 5000; 

        const SCARE_RADIUS = 40;       

        let canvas;
        let butterflies = []; 
        let lastClickTime; 

        // Variabler för träd och animation
        let treeLandingSpots = []; 
        let treeSegments = [];     
        let treeDrawn = false;     
        let treeAnimationStartTime = 0; 
        
        // --- P5.JS KNAPP-KONSTANTER ---
        const BUTTON_SIZE = 24;
        const BUTTON_PADDING = 16;
        const BUTTON_START_X = 80;
        const BUTTON_START_Y = 20;

        // Definierar knapparnas positioner (inuti P5.js canvas)
        const BUTTONS = {
            TREE: {
                x: BUTTON_START_X,
                y: BUTTON_START_Y,
                w: BUTTON_SIZE,
                h: BUTTON_SIZE
            },
            CLEAR: {
                x: BUTTON_START_X + BUTTON_SIZE + BUTTON_PADDING, // 80 + 24 + 16 = 120
                y: BUTTON_START_Y,
                w: BUTTON_SIZE,
                h: BUTTON_SIZE
            }
        };


        /**
         * Klass för att representera ett enda linjesegment i trädet.
         */
        class Segment {
            constructor(start, end) {
                this.start = start;
                this.end = end;
            }
        }

        /**
         * Klass för att representera en enskild fjäril (Boid).
         */
        class Butterfly {
            constructor(x, y, isAttractionActiveOnPress = false) { 
                this.position = createVector(x, y);
                this.velocity = p5.Vector.random2D(); 
                this.velocity.setMag(random(1.0, 1.8)); 
                this.acceleration = createVector(0, 0);
                
                this.wingLength = random(5, 10); 
                this.strokeWeight = random(1, 2); 
                this.color = random(COLOR_PALETTE); 
                
                this.flapOffset = random(0, TWO_PI);
                this.noiseOffset = random(1000);
                
                this.maxSpeed = random(1.0, 1.8);          
                this.flapSpeed = random(0.1, 0.35);        
                this.verticalStudScale = random(3, 8);     
                this.noiseScale = random(0.02, 0.035);    

                // --- Landningsstatus ---
                this.isLanded = false;
                this.targetSpot = null; 
                
                if (isAttractionActiveOnPress) {
                    this.scareTimer = millis() + SCARE_DURATION_MS;
                } else {
                    this.scareTimer = 0; 
                }
            }

            /** Applicerar en kraft på fjärilens acceleration. */
            applyForce(force) {
                this.acceleration.add(force);
            }

            /** Beräknar en styrkraft för att flyga mot en given vektor. */
            seek(target) {
                let desired = p5.Vector.sub(target, this.position);
                desired.setMag(this.maxSpeed);
                let steer = p5.Vector.sub(desired, this.velocity);
                steer.limit(MAX_FORCE);
                return steer;
            }

            /** --- Boid Rule 1: Separation --- */
            separate(butterflies) {
                let steering = createVector(0, 0);
                let total = 0;
                
                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < SEPARATION_DISTANCE) {
                        let diff = p5.Vector.sub(this.position, other.position);
                        diff.normalize(); 
                        diff.div(d);     
                        steering.add(diff);
                        total++;
                    }
                }
                
                if (total > 0) {
                    steering.div(total); 
                    steering.setMag(this.maxSpeed); 
                    steering.sub(this.velocity); 
                    steering.limit(MAX_FORCE);
                }
                return steering;
            }

            /** --- Boid Rule 2: Alignment --- */
            align(butterflies) {
                let sum = createVector(0, 0);
                let count = 0;
                
                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < PERCEPTION_RADIUS) {
                        sum.add(other.velocity);
                        count++;
                    }
                }

                if (count > 0) {
                    sum.div(count); 
                    sum.setMag(this.maxSpeed);
                    let steer = p5.Vector.sub(sum, this.velocity);
                    steer.limit(MAX_FORCE);
                    return steer;
                }
                return createVector(0, 0);
            }

            /** --- Boid Rule 3: Cohesion --- */
            cohere(butterflies) {
                let centerOfMass = createVector(0, 0);
                let count = 0;

                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < PERCEPTION_RADIUS) {
                        centerOfMass.add(other.position);
                        count++;
                    }
                }

                if (count > 0) {
                    centerOfMass.div(count); 
                    return this.seek(centerOfMass); 
                }
                return createVector(0, 0);
            }

            /** Beräknar en drivkraft från Perlin Noise. */
            calculateNoiseForce() {
                let angle = noise(this.noiseOffset, frameCount * this.noiseScale) * TWO_PI * 4; 
                let noiseVector = p5.Vector.fromAngle(angle);
                
                let steering = p5.Vector.sub(noiseVector.setMag(this.maxSpeed), this.velocity);
                steering.limit(MAX_FORCE); 
                steering.mult(NOISE_WEIGHT); 
                return steering;
            }
            
            /** Styr fjärilen mot trädets landningsplatser. */
            approachTarget() {
                // Sätt landningspositionen första gången
                if (this.targetSpot === null) {
                    if (treeLandingSpots.length > 0) {
                        this.targetSpot = random(treeLandingSpots);
                    } else {
                        return;
                    }
                }
                
                let targetPoint = this.targetSpot;

                // 2. Beräkna avståndet till målet
                let distToTarget = p5.Vector.dist(this.position, targetPoint);

                // 3. Landningscheck
                if (distToTarget < 5) { 
                    this.isLanded = true;
                    this.position = targetPoint.copy().add(random(-3, 3), random(-3, 3)); 
                    this.velocity.mult(0); 
                    this.acceleration.mult(0);
                } else {
                    // 4. Styr mot målet
                    let steer = this.seek(targetPoint);
                    this.applyForce(steer.mult(1.5)); 
                }
            }


            /** Sammanställer och applicerar alla Boid-regler. */
            flock(butterflies) {
                let separation = this.separate(butterflies);
                let alignment = this.align(butterflies);
                let cohesion = this.cohere(butterflies);

                // Applicera vikt (styrka) på krafterna
                separation.mult(SEPARATION_WEIGHT);
                alignment.mult(ALIGNMENT_WEIGHT);
                cohesion.mult(COHESION_WEIGHT);

                // Lägg till krafterna
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }

            /**
             * Uppdaterar fjärilens position.
             */
            update(butterflies, isAttractionActive) {
                if (this.isLanded) {
                    return; 
                }
                
                const isScared = millis() < this.scareTimer; 

                if (isAttractionActive && !isScared) {
                    this.approachTarget(); 
                } else {
                    this.flock(butterflies); 
                    let noiseForce = this.calculateNoiseForce();
                    this.applyForce(noiseForce);
                }

                // 3. Tillämpa fysik
                this.velocity.add(this.acceleration);
                this.velocity.limit(this.maxSpeed);
                this.position.add(this.velocity);
                
                // 4. Nollställ accelerationen
                this.acceleration.mult(0); 

                // 5. Wrap-around (Gränshantering)
                if (this.position.x < 0) this.position.x = width;
                if (this.position.x > width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = height;
                if (this.position.y > height) this.position.y = 0;
            }

            /**
             * Ritar fjärilen på canvasen och animerar dess flax och studs.
             */
            display() {
                let flap = sin(frameCount * this.flapSpeed + this.flapOffset) * FLAP_AMPLITUDE;
                let yOffset = -flap * this.verticalStudScale; 
                
                push();
                
                translate(this.position.x, this.position.y + yOffset);
                
                // TILT-LOGIK
                const MAX_TILT_RAD = QUARTER_PI; 
                let normalizedX = constrain(this.velocity.x / this.maxSpeed, -1, 1); 
                let tiltAngle = normalizedX * MAX_TILT_RAD;
                rotate(tiltAngle); 
                
                stroke(this.color); 
                strokeWeight(this.strokeWeight); 
                noFill();

                // Vingar
                push();
                rotate(-INITIAL_V_ANGLE - flap);
                line(0, 0, 0, -this.wingLength); 
                pop();

                push();
                rotate(INITIAL_V_ANGLE + flap);
                line(0, 0, 0, -this.wingLength);
                pop();

                pop();
            }
        }
        
        // --- Fraktal Träd Logik ---
        
        /**
         * Rekursiv funktion för att generera alla trädsegment och lagra dem.
         */
        function generateBranch(startPos, len, angle, depth) {
            if (depth > MAX_DEPTH) return;

            let dx = len * sin(angle);
            let dy = len * cos(angle);
            
            let endPos = createVector(startPos.x + dx, startPos.y - dy); 

            treeSegments.push(new Segment(startPos.copy(), endPos.copy()));

            if (depth >= 2) { 
                const numSamples = 4;
                for (let i = 1; i < numSamples; i++) {
                    let t = i / numSamples;
                    let spot = p5.Vector.lerp(startPos, endPos, t);
                    treeLandingSpots.push(spot);
                }
            }
            
            if (depth === MAX_DEPTH) {
                treeLandingSpots.push(endPos.copy());
            }


            if (depth < MAX_DEPTH) {
                let nextLen = len * 0.7;

                generateBranch(endPos, nextLen, angle - BRANCH_ANGLE, depth + 1);
                generateBranch(endPos, nextLen, angle + BRANCH_ANGLE, depth + 1);
            }
        }

        /**
         * Funktion för att förberäkna alla trädsegment.
         */
        function precalculateTree() {
            treeSegments = [];
            treeLandingSpots = [];
            
            const startPos = createVector(width / 2, height);
            
            generateBranch(startPos, INITIAL_LENGTH, 0, 0); 
        }

        /**
         * Ritar trädets segment baserat på animationens framsteg.
         */
        function drawAnimatedTree(progress) {
            if (treeSegments.length === 0) return;

            stroke('#333');
            strokeWeight(1); 
            noFill();

            const totalSegments = treeSegments.length;
            const segmentsToDraw = progress * totalSegments;

            const fullSegments = floor(segmentsToDraw);
            for (let i = 0; i < fullSegments; i++) {
                const seg = treeSegments[i];
                line(seg.start.x, seg.start.y, seg.end.x, seg.end.y);
            }

            if (fullSegments < totalSegments) {
                const seg = treeSegments[fullSegments];
                const partialProgress = segmentsToDraw - fullSegments; 

                const partialEnd = p5.Vector.lerp(seg.start, seg.end, partialProgress);
                line(seg.start.x, seg.start.y, partialEnd.x, partialEnd.y);
            }
        }
        
        /**
         * Växlar (toggle) trädets synlighet och startar/stoppar fjärilarnas landning.
         */
        function toggleTree() {
            if (treeDrawn) {
                // Träd finns: Ta bort det
                treeDrawn = false; 
                treeSegments = [];
                treeLandingSpots = []; 
                treeAnimationStartTime = 0;
                lastClickTime = millis(); 
                
                // Fjärilarna lyfter
                for (let b of butterflies) {
                    b.isLanded = false;
                    b.targetSpot = null; 
                    b.scareTimer = 0;    
                    b.acceleration.mult(0); 
                }

            } else {
                // Träd finns inte: Skapa det
                precalculateTree();
                treeAnimationStartTime = millis();
                treeDrawn = true; 
                lastClickTime = millis(); 
                
                // Fjärilarna lyfter för att flyga fritt tills trädet är klart
                for (let b of butterflies) {
                    b.isLanded = false;
                    b.targetSpot = null; 
                }
            }
        }
        
        /**
         * Ritar de två in-sketch-knapparna (Tree och Clear) med den nya stilen.
         */
        function drawButtons() {
            // Färg för 50% opacitet svart (51, 51, 51, 128)
            const HALF_ALPHA_COLOR = color(51, 51, 51, 128); 

            // Ritar knapparna
            for (let key in BUTTONS) {
                const btn = BUTTONS[key];
                
                push();
                
                // 1. RITA RAMEN (50% opacitet)
                stroke(HALF_ALPHA_COLOR); 
                strokeWeight(1); // 1px kantlinje
                
                // Ingen fyllning för någon av knapparna
                noFill(); 
                
                // Rita den 24x24 stora knappen med rundade hörn
                rect(btn.x, btn.y, btn.w, btn.h, 4); 

                // Ritar symbolerna (nu 10x10, centrerade)
                
                const iconSize = 10;
                const iconPadding = (btn.w - iconSize) / 2; // (24 - 10) / 2 = 7
                
                const iconXStart = btn.x + iconPadding; // x + 7
                const iconYStart = btn.y + iconPadding; // y + 7
                const iconXEnd = btn.x + btn.w - iconPadding; // x + 17
                const iconYEnd = btn.y + btn.h - iconPadding; // y + 17
                const iconCenterX = btn.x + btn.w / 2; // x + 12
                
                if (key === 'TREE') {
                    // Symbol: Ett enkelt träd (stam och en triangel)
                    
                    // 2. STAM (50% opacitet)
                    stroke(HALF_ALPHA_COLOR);
                    strokeWeight(1.5);
                    
                    // Stam (från ca 60% till 95% av ikonområdet)
                    line(iconCenterX, iconYStart + iconSize * 0.6, iconCenterX, iconYEnd - 1); 
                    
                    // 3. KRONA (50% opacitet)
                    noStroke();
                    fill(HALF_ALPHA_COLOR);
                    // Krona (Triangel, tar upp toppen av ikonområdet)
                    triangle(
                        iconXStart, iconYEnd - iconSize * 0.4, // Base Left 
                        iconXEnd, iconYEnd - iconSize * 0.4,   // Base Right
                        iconCenterX, iconYStart + 1            // Tip (slightly down from top edge)
                    );
                    
                } else { // CLEAR
                    // Symbol: Ett enkelt X (10x10, fyller ikonområdet)
                    
                    // 2. KRYSS (50% opacitet)
                    stroke(HALF_ALPHA_COLOR);
                    strokeWeight(1.5);
                    
                    // Linjer (diagonaler)
                    line(iconXStart, iconYStart, iconXEnd, iconYEnd);       // Top-Left till Bottom-Right
                    line(iconXEnd, iconYStart, iconXStart, iconYEnd);       // Top-Right till Bottom-Left
                }
                
                pop();
            }
        }
        
        /**
         * Kontrollerar om mus/touch klickade på en av knapparna.
         * @returns {boolean} True om en knapp klickades, annars False.
         */
        function checkButtonClicks() {
            for (let key in BUTTONS) {
                const btn = BUTTONS[key];
                
                // Kontrollerar om musX/musY är inom knappens gränser
                if (mouseX >= btn.x && mouseX <= btn.x + btn.w &&
                    mouseY >= btn.y && mouseY <= btn.y + btn.h) {
                    
                    if (key === 'TREE') {
                        toggleTree();
                    } else if (key === 'CLEAR') {
                        // Clear-logiken
                        butterflies = []; 
                        lastClickTime = millis(); 
                        treeDrawn = false; 
                        treeSegments = [];
                        treeLandingSpots = []; 
                        treeAnimationStartTime = 0; 
                        if (canvas) {
                            background('#f7f7f7'); 
                        }
                    }
                    return true; // En knapp klickades
                }
            }
            return false; // Ingen knapp klickades
        }


        // --- P5.js Standardfunktioner ---

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight);
            canvas.style('display', 'block');
            background('#f7f7f7'); 
            lastClickTime = millis(); 
        }

        function draw() {
            background('#f7f7f7'); 

            let isAttractionActive = false;
            
            if (treeDrawn) { 
                
                const isAttractionFullyActive = (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS);

                const elapsedTime = millis() - treeAnimationStartTime;
                let treeProgress = constrain(elapsedTime / MAX_ANIMATION_TIME_MS, 0, 1);
                
                drawAnimatedTree(treeProgress);

                if (treeProgress >= 1.0) {
                    isAttractionActive = true;
                }
            }
            
            for (let butterfly of butterflies) {
                butterfly.update(butterflies, isAttractionActive); 
                butterfly.display();
            }
            
            // Ritar knapparna OVANPÅ allt annat
            drawButtons();
        }

        /**
         * Hanterar musrörelser för att skrämma bort landade fjärilar.
         */
        function mouseMoved() {
            const isAttractionActive = (treeDrawn && (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS));

            if (isAttractionActive) {
                const mousePos = createVector(mouseX, mouseY);
                
                for (let b of butterflies) {
                    if (b.isLanded) {
                        let d = p5.Vector.dist(mousePos, b.position);

                        if (d < SCARE_RADIUS) {
                            b.isLanded = false;
                            b.targetSpot = null; 
                            b.scareTimer = millis() + SCARE_DURATION_MS; 
                            
                            let escapeVector = p5.Vector.sub(b.position, mousePos);
                            escapeVector.normalize();
                            
                            b.velocity = escapeVector.copy().mult(b.maxSpeed * 4.0); 
                            b.applyForce(escapeVector.mult(2.0));                     
                        }
                    }
                }
            }
            // Returvärdet 'false' förhindrar standard-scrollbeteende på mobiler
            return false; 
        }


        /**
         * Skapar fjärilar ELLER triggar en knappklick.
         */
        function mousePressed() {
            // 1. Kontrollera om en knapp klickades
            if (checkButtonClicks()) {
                // Om en knapp klickades, stoppa exekveringen HÄR för att undvika att skapa fjärilar.
                return false; 
            }

            // 2. Om ingen knapp klickades, skapa fjärilar (gammal logik)
            const isAttractionActiveOnPress = (treeDrawn && (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS));

            for (let i = 0; i < BUTTERFLY_COUNT; i++) {
                let offsetX = random(-SCATTER_RADIUS, SCATTER_RADIUS);
                let offsetY = random(-SCATTER_RADIUS, SCATTER_RADIUS);
                
                let startX = mouseX + offsetX;
                let startY = mouseY + offsetY;
                
                let newButterfly = new Butterfly(startX, startY, isAttractionActiveOnPress);
                butterflies.push(newButterfly);
            }
            return false; 
        }
        
        // Denna eventlyssnare är inte längre nödvändig eftersom knapparna är i P5.js.
        // document.addEventListener('DOMContentLoaded', () => { ... });


        // Hanterar responsivitet: Ändra canvasstorleken när fönstret ändras
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            if(treeDrawn) {
                precalculateTree(); 
            }
        }
    </script>
</body>
</html>
