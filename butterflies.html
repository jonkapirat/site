<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5.js Fjärilssvärm Boids</title>
    <!-- Laddar in Tailwind CSS för enklare layout och responsivitet -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Laddar in p5.js biblioteket -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        /* Sätter HTML och Body till full höjd och bredd för att fylla webbläsaren */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Förhindrar scrollning */
            height: 100%;
            cursor: pointer; /* Visuell hint att man kan klicka */
        }
        /* Säkerställer att p5.js canvas fyller sin container */
        canvas {
            display: block;
        }
        
        /* Delad styling för kontrollknappar */
        .control-button {
            position: absolute;
            top: 20px; /* Uppdaterad till 20px från överkanten */
            z-index: 10;
            cursor: pointer;
            
            /* Förbättrar respons på touch-skärmar, förhindrar fördröjning */
            touch-action: manipulation; 
            
            /* Minimalistisk Styling */
            padding: 4px 12px;
            border-radius: 6px; 
            font-family: sans-serif;
            font-size: 14px;
            font-weight: 400; 
            color: #333; 
            background-color: #fff;
            border: 1px solid #333; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: all 0.15s ease-in-out;
        }

        /* Placering av Tree-knappen (80px från vänsterkanten) */
        #treeButton {
            left: 80px; /* Uppdaterad till 80px från vänsterkanten */
        }

        /* Placering av Clear-knappen (till höger om Tree-knappen, ca 15px mellanrum) */
        #clearButton {
            left: 155px; /* Ca 80px + 60px bredd + 15px mellanrum */
        }

        .control-button:hover {
            background-color: #f0f0f0; /* Subtil hover-effekt */
            color: #111;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: translateY(-0.5px);
        }
    </style>
</head>
<body class="bg-[#f7f7f7] antialiased flex items-center justify-center h-screen w-screen">
    <!-- Ny Tree-knapp -->
    <button id="treeButton" class="control-button">Tree</button>
    <!-- Clear-knapp -->
    <button id="clearButton" class="control-button">Clear</button>

    <script>
        // Globala konstanter för fjärilens gemensamma utseende/gränser
        const BUTTERFLY_COUNT = 20;       // Antal fjärilar som skapas per klick
        const INITIAL_V_ANGLE = Math.PI / 6; // Grundvinkel för V-formen (startöppning)
        const FLAP_AMPLITUDE = Math.PI / 8; // Hur mycket vingarna maximalt öppnas/stängs (gemensamt för alla)
        const SCATTER_RADIUS = 15;        // Maximalt avstånd från klickpunkten vid initiering
        
        // FÄRG PALETT
        const COLOR_PALETTE = [
            '#4CAF50', // Grön
            '#FFC107', // Gul
            '#64B5F6', // Ljusblå
            '#3F51B5', // Marinblå
            '#FF6361'  // Korall/Röd
        ];

        // --- Boid / Flockningskonstanter ---
        const MAX_FORCE = 0.02;   
        const PERCEPTION_RADIUS = 80; 
        const SEPARATION_DISTANCE = 30; 
        const NOISE_WEIGHT = 0.4;    
        const COHESION_WEIGHT = 1.0; 
        const ALIGNMENT_WEIGHT = 0.4; 
        const SEPARATION_WEIGHT = 3.0; 

        // --- Mål/Landningskonstanter ---
        const SCARE_DURATION_MS = 4000; // 4 sekunder som fjärilarna flyr/flyger i flock innan de återvänder
        
        // Fractal Tree konstanter
        const MAX_DEPTH = 4;           // Antal rekursiva delningar
        const INITIAL_LENGTH = 100;    // Startlängd för stammen
        const BRANCH_ANGLE = Math.PI / 6; // 30 graders vinkel för delning
        const MAX_ANIMATION_TIME_MS = 5000; // 5 sekunder för att rita hela trädet

        const SCARE_RADIUS = 40;       // Muspekarens skrämselradie i pixlar

        let canvas;
        let butterflies = []; 
        let lastClickTime; // Behålls för att kunna återanvända om timer läggs till igen

        // Variabler för träd och animation
        let treeLandingSpots = []; // Lagrar koordinater för fjärilarnas landning
        let treeSegments = [];     // Lagrar alla linjesegment för trädets teckningsanimation
        let treeDrawn = false;     // Flagg: Är trädet aktivt (under ritning eller klart)?
        let treeAnimationStartTime = 0; // Tiden (millis) när trädet började ritas

        /**
         * Klass för att representera ett enda linjesegment i trädet.
         */
        class Segment {
            constructor(start, end) {
                this.start = start;
                this.end = end;
            }
        }

        /**
         * Klass för att representera en enskild fjäril (Boid).
         */
        class Butterfly {
            constructor(x, y, isAttractionActiveOnPress = false) { 
                this.position = createVector(x, y);
                this.velocity = p5.Vector.random2D(); 
                this.velocity.setMag(random(1.0, 1.8)); 
                this.acceleration = createVector(0, 0);
                
                this.wingLength = random(5, 10); 
                this.strokeWeight = random(1, 2); 
                this.color = random(COLOR_PALETTE); 
                
                this.flapOffset = random(0, TWO_PI);
                this.noiseOffset = random(1000);
                
                this.maxSpeed = random(1.0, 1.8);          
                this.flapSpeed = random(0.1, 0.35);        
                this.verticalStudScale = random(3, 8);     
                this.noiseScale = random(0.02, 0.035);    

                // --- Landningsstatus ---
                this.isLanded = false;
                this.targetSpot = null; // Den tilldelade landningsplatsen på trädet
                
                // Om trädet är aktivt vid klicket (dvs. vi injicerar), starta skrämseltimern
                // Detta får den nya svärmen att flyga fritt i 4 sekunder innan landning.
                if (isAttractionActiveOnPress) {
                    this.scareTimer = millis() + SCARE_DURATION_MS;
                } else {
                    this.scareTimer = 0; 
                }
            }

            /** Applicerar en kraft på fjärilens acceleration. */
            applyForce(force) {
                this.acceleration.add(force);
            }

            /** Beräknar en styrkraft för att flyga mot en given vektor. */
            seek(target) {
                let desired = p5.Vector.sub(target, this.position);
                desired.setMag(this.maxSpeed);
                let steer = p5.Vector.sub(desired, this.velocity);
                steer.limit(MAX_FORCE);
                return steer;
            }

            /** --- Boid Rule 1: Separation --- */
            separate(butterflies) {
                let steering = createVector(0, 0);
                let total = 0;
                
                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < SEPARATION_DISTANCE) {
                        let diff = p5.Vector.sub(this.position, other.position);
                        diff.normalize(); 
                        diff.div(d);     
                        steering.add(diff);
                        total++;
                    }
                }
                
                if (total > 0) {
                    steering.div(total); 
                    steering.setMag(this.maxSpeed); 
                    steering.sub(this.velocity); 
                    steering.limit(MAX_FORCE);
                }
                return steering;
            }

            /** --- Boid Rule 2: Alignment --- */
            align(butterflies) {
                let sum = createVector(0, 0);
                let count = 0;
                
                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < PERCEPTION_RADIUS) {
                        sum.add(other.velocity);
                        count++;
                    }
                }

                if (count > 0) {
                    sum.div(count); 
                    sum.setMag(this.maxSpeed);
                    let steer = p5.Vector.sub(sum, this.velocity);
                    steer.limit(MAX_FORCE);
                    return steer;
                }
                return createVector(0, 0);
            }

            /** --- Boid Rule 3: Cohesion --- */
            cohere(butterflies) {
                let centerOfMass = createVector(0, 0);
                let count = 0;

                for (let other of butterflies) {
                    let d = p5.Vector.dist(this.position, other.position);
                    if (other !== this && d < PERCEPTION_RADIUS) {
                        centerOfMass.add(other.position);
                        count++;
                    }
                }

                if (count > 0) {
                    centerOfMass.div(count); 
                    return this.seek(centerOfMass); 
                }
                return createVector(0, 0);
            }

            /** Beräknar en drivkraft från Perlin Noise. */
            calculateNoiseForce() {
                let angle = noise(this.noiseOffset, frameCount * this.noiseScale) * TWO_PI * 4; 
                let noiseVector = p5.Vector.fromAngle(angle);
                
                let steering = p5.Vector.sub(noiseVector.setMag(this.maxSpeed), this.velocity);
                steering.limit(MAX_FORCE); 
                steering.mult(NOISE_WEIGHT); 
                return steering;
            }
            
            /** Styr fjärilen mot trädets landningsplatser. */
            approachTarget() {
                // Sätt landningspositionen första gången
                if (this.targetSpot === null) {
                    if (treeLandingSpots.length > 0) {
                        // Välj en slumpmässig, tillgänglig landningsplats från trädet
                        this.targetSpot = random(treeLandingSpots);
                    } else {
                        // Om inga landningsplatser finns, gör inget
                        return;
                    }
                }
                
                let targetPoint = this.targetSpot;

                // 2. Beräkna avståndet till målet
                let distToTarget = p5.Vector.dist(this.position, targetPoint);

                // 3. Landningscheck
                if (distToTarget < 5) { // Om den är nära nog
                    this.isLanded = true;
                    // Lås positionen till målet med en liten slumpmässig offset
                    this.position = targetPoint.copy().add(random(-3, 3), random(-3, 3)); 
                    this.velocity.mult(0); // Stanna rörelse
                    this.acceleration.mult(0);
                } else {
                    // 4. Styr mot målet
                    let steer = this.seek(targetPoint);
                    // Ge en starkare dragningskraft mot målet för att landa snabbare
                    this.applyForce(steer.mult(1.5)); 
                }
            }


            /** Sammanställer och applicerar alla Boid-regler. */
            flock(butterflies) {
                let separation = this.separate(butterflies);
                let alignment = this.align(butterflies);
                let cohesion = this.cohere(butterflies);

                // Applicera vikt (styrka) på krafterna
                separation.mult(SEPARATION_WEIGHT);
                alignment.mult(ALIGNMENT_WEIGHT);
                cohesion.mult(COHESION_WEIGHT);

                // Lägg till krafterna
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }

            /**
             * Uppdaterar fjärilens position.
             * @param {Butterfly[]} butterflies Alla fjärilar i svärmen.
             * @param {boolean} isAttractionActive Är trädet ritat och redo för landning?
             */
            update(butterflies, isAttractionActive) {
                if (this.isLanded) {
                    // Om landad, gör inget annat än att rita (vingslagen fortsätter i display())
                    return; 
                }
                
                // Kontrollerar om fjärilen fortfarande är i flykt/skrämsel-läge
                const isScared = millis() < this.scareTimer; 

                if (isAttractionActive && !isScared) {
                    // Om attraktion är aktiv OCH fjärilen inte är skrämd, styr mot trädets grenar
                    this.approachTarget(); 
                } else {
                    // Annars (om inte aktiv eller om skrämd), kör normal Boid-logik
                    this.flock(butterflies); 
                    let noiseForce = this.calculateNoiseForce();
                    this.applyForce(noiseForce);
                }

                // 3. Tillämpa fysik
                this.velocity.add(this.acceleration);
                this.velocity.limit(this.maxSpeed);
                this.position.add(this.velocity);
                
                // 4. Nollställ accelerationen
                this.acceleration.mult(0); 

                // 5. Wrap-around (Gränshantering)
                if (this.position.x < 0) this.position.x = width;
                if (this.position.x > width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = height;
                if (this.position.y > height) this.position.y = 0;
            }

            /**
             * Ritar fjärilen på canvasen och animerar dess flax och studs.
             */
            display() {
                // Vingslagen beror enbart på frameCount, så de fortsätter även när isLanded=true
                let flap = sin(frameCount * this.flapSpeed + this.flapOffset) * FLAP_AMPLITUDE;
                let yOffset = -flap * this.verticalStudScale; 
                
                push();
                
                translate(this.position.x, this.position.y + yOffset);
                
                // TILT-LOGIK
                const MAX_TILT_RAD = QUARTER_PI; 
                let normalizedX = constrain(this.velocity.x / this.maxSpeed, -1, 1); 
                let tiltAngle = normalizedX * MAX_TILT_RAD;
                rotate(tiltAngle); 
                
                stroke(this.color); 
                strokeWeight(this.strokeWeight); 
                noFill();

                // Vingar
                push();
                rotate(-INITIAL_V_ANGLE - flap);
                line(0, 0, 0, -this.wingLength); 
                pop();

                push();
                rotate(INITIAL_V_ANGLE + flap);
                line(0, 0, 0, -this.wingLength);
                pop();

                pop();
            }
        }
        
        // --- Fraktal Träd Logik ---
        
        /**
         * Rekursiv funktion för att generera alla trädsegment och lagra dem.
         * Den samlar även landningsplatserna (treeLandingSpots).
         * @param {p5.Vector} startPos Absolut startposition.
         * @param {number} len Längden på den aktuella grenen.
         * @param {number} angle Aktuell rotationsvinkel (0 = rakt upp).
         * @param {number} depth Aktuellt djup.
         */
        function generateBranch(startPos, len, angle, depth) {
            if (depth > MAX_DEPTH) return;

            // Beräkna slutposition
            let dx = len * sin(angle);
            let dy = len * cos(angle);
            
            // Y är inverterad i p5.js, så vi subtraherar dy
            let endPos = createVector(startPos.x + dx, startPos.y - dy); 

            // Lagra segmentet
            treeSegments.push(new Segment(startPos.copy(), endPos.copy()));

            // Samla landningspunkter längs segmentet endast för djup 2 och högre
            // Detta filtrerar bort landningsplatser från stammen och de första stora grenarna (gren 1 och 2).
            if (depth >= 2) { 
                const numSamples = 4;
                for (let i = 1; i < numSamples; i++) {
                    let t = i / numSamples;
                    let spot = p5.Vector.lerp(startPos, endPos, t);
                    treeLandingSpots.push(spot);
                }
            }
            
            // Lägg till spetsen som sista landningsplats (endast för sista djupet)
            if (depth === MAX_DEPTH) {
                treeLandingSpots.push(endPos.copy());
            }


            // Stoppvillkor och rekursiva anrop
            if (depth < MAX_DEPTH) {
                let nextLen = len * 0.7;

                // Gren 1 (vänster)
                generateBranch(endPos, nextLen, angle - BRANCH_ANGLE, depth + 1);

                // Gren 2 (höger)
                generateBranch(endPos, nextLen, angle + BRANCH_ANGLE, depth + 1);
            }
        }

        /**
         * Funktion för att förberäkna alla trädsegment.
         * Körs endast en gång när trädet aktiveras.
         */
        function precalculateTree() {
            treeSegments = [];
            treeLandingSpots = [];
            
            // Startposition: Mitt på bottenkanten
            const startPos = createVector(width / 2, height);
            
            // Starta rekursion. Vinkel 0 är rakt upp.
            generateBranch(startPos, INITIAL_LENGTH, 0, 0); 
        }

        /**
         * Ritar trädets segment baserat på animationens framsteg.
         * @param {number} progress Animationens framsteg (0.0 till 1.0).
         */
        function drawAnimatedTree(progress) {
            if (treeSegments.length === 0) return;

            stroke('#333');
            strokeWeight(1); // Smalare grenar
            noFill();

            const totalSegments = treeSegments.length;
            const segmentsToDraw = progress * totalSegments;

            // 1. Rita alla helt färdiga segment
            const fullSegments = floor(segmentsToDraw);
            for (let i = 0; i < fullSegments; i++) {
                const seg = treeSegments[i];
                line(seg.start.x, seg.start.y, seg.end.x, seg.end.y);
            }

            // 2. Rita det delvis färdiga segmentet (där "pennan" ritar just nu)
            if (fullSegments < totalSegments) {
                const seg = treeSegments[fullSegments];
                const partialProgress = segmentsToDraw - fullSegments; // Den del av segmentet som ska ritas

                const partialEnd = p5.Vector.lerp(seg.start, seg.end, partialProgress);
                line(seg.start.x, seg.start.y, partialEnd.x, partialEnd.y);
            }
        }
        
        /**
         * Växlar (toggle) trädets synlighet och startar/stoppar fjärilarnas landning.
         */
        function toggleTree() {
            if (treeDrawn) {
                // Träd finns: Ta bort det och starta flykt för alla fjärilar
                treeDrawn = false; 
                treeSegments = [];
                treeLandingSpots = []; 
                treeAnimationStartTime = 0;
                lastClickTime = millis(); // Uppdatera tiden för att markera aktivitet
                
                // Alla befintliga fjärilar lyfter och flyger fritt
                for (let b of butterflies) {
                    b.isLanded = false;
                    b.targetSpot = null; 
                    b.scareTimer = 0;    
                    b.acceleration.mult(0); 
                }

            } else {
                // Träd finns inte: Skapa det
                
                // 1. Förberäkna segment
                precalculateTree();
                // 2. Starta animationstimer
                treeAnimationStartTime = millis();
                // 3. Markera som aktiv/under ritning
                treeDrawn = true; 
                lastClickTime = millis(); // Uppdatera tiden för att markera aktivitet
                
                // Om fjärilar redan finns, tvinga dem att lyfta och flyga fritt (scareTimer=0) 
                // innan de dras mot det nya trädet när det är klart.
                for (let b of butterflies) {
                    b.isLanded = false;
                    b.targetSpot = null; 
                    // Obs: scareTimer sätts inte här, de flyger fritt direkt tills trädet är ritat.
                }
            }
        }


        // --- P5.js Standardfunktioner ---

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight);
            canvas.style('display', 'block');
            background('#f7f7f7'); 
            lastClickTime = millis(); // Initialisera
        }

        function draw() {
            // Rensa bakgrunden i varje frame
            background('#f7f7f7'); 

            let isAttractionActive = false;
            
            // Om trädet är aktivt (treeDrawn=true), rita det och beräkna landningsattraktion.
            if (treeDrawn) { 
                
                // Kontrollerar om trädet är helt ritat (attraktionen aktiv)
                const isAttractionFullyActive = (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS);

                const elapsedTime = millis() - treeAnimationStartTime;
                let treeProgress = constrain(elapsedTime / MAX_ANIMATION_TIME_MS, 0, 1);
                
                drawAnimatedTree(treeProgress);

                // Aktivera attraktion ENDAST när trädet är helt ritat (progress = 1.0)
                if (treeProgress >= 1.0) {
                    isAttractionActive = true;
                }
            }
            
            // Uppdatera position och rita varje fjäril.
            for (let butterfly of butterflies) {
                butterfly.update(butterflies, isAttractionActive); 
                butterfly.display();
            }
        }

        /**
         * Hanterar musrörelser för att skrämma bort landade fjärilar.
         * Denna funktion körs endast när musen rör sig över canvas.
         */
        function mouseMoved() {
            // Kontrollera om fjärilarna ska vara landade (dvs. trädet är ritat och attraktionen är aktiv)
            const isAttractionActive = (treeDrawn && (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS));

            if (isAttractionActive) {
                // Vi använder mouseX och mouseY globalt från p5.js
                const mousePos = createVector(mouseX, mouseY);
                
                for (let b of butterflies) {
                    // Endast skräm om fjärilen har landat
                    if (b.isLanded) {
                        let d = p5.Vector.dist(mousePos, b.position);

                        if (d < SCARE_RADIUS) {
                            // 1. "Lyft" fjärilen, rensa målet och sätt skrämseltimer
                            b.isLanded = false;
                            b.targetSpot = null; 
                            b.scareTimer = millis() + SCARE_DURATION_MS; // Skrämd i 4 sekunder
                            
                            // 2. Beräkna avstötningskraft (flyger bort från muspekaren)
                            let escapeVector = p5.Vector.sub(b.position, mousePos);
                            escapeVector.normalize();
                            
                            // Ställ in en snabbare utgångshastighet och knuff för större flykt
                            b.velocity = escapeVector.copy().mult(b.maxSpeed * 4.0); 
                            b.applyForce(escapeVector.mult(2.0));                     
                        }
                    }
                }
                
                // lastClickTime uppdateras inte, så trädet står kvar.
            }
            return false; // Förhindra standardhantering av musrörelse
        }


        /**
         * Skapar BUTTERFLY_COUNT (20) nya fjärilar vid musens position.
         */
        function mousePressed() {
            // Kontrollera om trädet redan är framme och helt ritat (dvs. attraktion är aktiv)
            const isAttractionActiveOnPress = (treeDrawn && (millis() - treeAnimationStartTime >= MAX_ANIMATION_TIME_MS));

            // Skapa nya fjärilar
            for (let i = 0; i < BUTTERFLY_COUNT; i++) {
                let offsetX = random(-SCATTER_RADIUS, SCATTER_RADIUS);
                let offsetY = random(-SCATTER_RADIUS, SCATTER_RADIUS);
                
                let startX = mouseX + offsetX;
                let startY = mouseY + offsetY;
                
                // Om trädet ÄR aktivt, får de nya fjärilarna en 4s skrämseltimer (Boids-flykt).
                // Annars flyger de fritt från start.
                let newButterfly = new Butterfly(startX, startY, isAttractionActiveOnPress);
                butterflies.push(newButterfly);
            }
            return false; 
        }
        
        // P5.js har inbyggd hantering för touch. För att hantera touch på canvasen
        // använder vi mousePressed() och mouseMoved(). För knapparna (som är utanför
        // canvasen), använder vi standard 'click' eventlyssnare, vilket är det
        // bästa sättet att hantera både mus och touch-input för HTML-element.
        

        // Lägger till eventlyssnare för knapparna
        document.addEventListener('DOMContentLoaded', () => {
            const clearButton = document.getElementById('clearButton');
            const treeButton = document.getElementById('treeButton'); 
            
            if (clearButton) {
                clearButton.addEventListener('click', () => {
                    butterflies = []; 
                    lastClickTime = millis(); 
                    treeDrawn = false; // Återställer trädflaggor
                    treeSegments = [];
                    treeLandingSpots = []; // Rensa landningsplatser
                    treeAnimationStartTime = 0; // Nollställ animationstimern
                    if (canvas) {
                        background('#f7f7f7'); 
                    }
                });
            }

            if (treeButton) {
                treeButton.addEventListener('click', toggleTree);
            }
        });


        // Hanterar responsivitet: Ändra canvasstorleken när fönstret ändras
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>
