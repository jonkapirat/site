<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>tile</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css">

  <style>
    body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background:#fff; }
    #map { height: 100vh; width: 100vw; }

    /* Distans + export “pill” uppe till vänster, strax höger om + */
    #info-panel { position: absolute; top: 10px; left: 56px; z-index: 1000; }
    .gpx-toolbar.leaflet-draw-toolbar.leaflet-bar { margin-top: 4px; }

    /* TRK-lista */
    .gpx-list-panel {
      position: absolute; z-index: 1000; background: #fff; border-radius: .25rem;
      box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.1);
      width: 240px; overflow: hidden; display: none;
    }
    .gpx-list-panel.open { display: block; }
    .gpx-list-item { padding: 8px 10px; cursor: pointer; }
    .gpx-list-item:hover { background: #f3f4f6; }

    /* Vänster verktygsrad – textknappar som matchar Leaflet */
    .leaflet-draw-toolbar .gpx-btn,
    .leaflet-draw-toolbar .gps-btn {
      width: 30px; height: 30px; display:flex; align-items:center; justify-content:center;
      background:#fff; border:1px solid #ccc; border-bottom:none; color:#464646; font-size:10px; font-weight:400;
      line-height:30px; text-decoration:none; cursor:pointer; box-sizing:border-box; background-image:none!important;
    }
    .leaflet-draw-toolbar .gpx-btn:last-of-type,
    .leaflet-draw-toolbar .gps-btn:last-of-type { border-bottom:1px solid #ccc; }
    .leaflet-draw-toolbar .gpx-btn:hover,
    .leaflet-draw-toolbar .gps-btn:hover { background:#f4f4f4; }
    .gps-active { outline: 2px solid #60a5fa; outline-offset: -1px; }

    /* Positionsmarkör: blå punkt + pil + fan */
    .heading-marker { position: relative; width: 28px; height: 28px; }
    .heading-marker .dot {
      width: 12px; height: 12px; background: #3b82f6; border:2px solid #fff; border-radius:50%;
      position: absolute; top: 8px; left: 8px; box-shadow:0 0 4px rgba(0,0,0,.25); z-index:2;
    }
    .heading-marker .arrow-wrap {
      position:absolute; top:-2px; left:-2px; width:32px; height:32px;
      transform-origin:50% 50%; will-change: transform; z-index:1;
    }
    .heading-marker .arrow-svg { width:32px; height:32px; display:block; }
    .heading-unknown .arrow-wrap { opacity:.45; }
  </style>
</head>
<body>

  <div id="map"></div>

  <!-- Distans + Export -->
  <div id="info-panel">
    <div class="flex items-center gap-3 bg-white/95 backdrop-blur px-4 py-2 rounded-full shadow">
      <span class="text-sm text-red-600 font-bold" id="distance-output">0.00 km</span>
      <button id="export-btn" disabled
        class="px-4 py-1.5 rounded-full text-sm font-semibold text-white bg-black disabled:opacity-50 disabled:cursor-not-allowed">
        Export
      </button>
    </div>
  </div>

  <!-- Dropdown för fördefinierade spår -->
  <div id="gpxListPanel" class="gpx-list-panel">
    <div class="px-3 py-2 text-sm font-semibold border-b border-gray-200">Fördefinierade spår</div>
    <div id="gpxList" class="max-h-72 overflow-auto"></div>
    <div id="gpxListEmpty" class="p-3 text-xs text-gray-500 hidden">
      Hittade inga spår. Säkerställ att <code>gpx-tracks/manifest.json</code> finns.
    </div>
  </div>

  <!-- Libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>

  <script>
  document.addEventListener('DOMContentLoaded', function () {
    const MAX_ZOOM = 17;
    const START = { lat: 56.15666, lng: 15.84580, zoom: 15 };

    // Karta + lager (OSM bas, Orion overlay, Esri satellit valbart)
    const map = L.map('map', { center: [START.lat, START.lng], zoom: START.zoom });

    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      noWrap: true, maxZoom: MAX_ZOOM, attribution: '© OpenStreetMap-bidragsgivare'
    }).addTo(map);

    const esriSat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { noWrap: true, maxZoom: MAX_ZOOM, attribution: 'Imagery © Esri, Maxar, Earthstar Geographics' }
    );

    const orionOverlay = L.tileLayer(
      'https://okorion.com/maptiles/orienteering/wgs84/{z}/{x}/{y}.png',
      { noWrap: true, maxZoom: MAX_ZOOM, attribution: '© OK Orion', pane: 'overlayPane', zIndex: 400, detectRetina: false }
    ).addTo(map);

    L.control.layers(
      { 'OpenStreetMap (bas)': osm, 'Satellit (Esri World Imagery)': esriSat },
      { 'OK Orion (överlagrat)': orionOverlay },
      { position: 'topright' }
    ).addTo(map);

    // Ritverktyg
    const drawnItems = new L.FeatureGroup(); map.addLayer(drawnItems);
    const drawControl = new L.Control.Draw({
      position:'topleft',
      edit:{ featureGroup: drawnItems, remove:true, poly:{ allowIntersection:false }},
      draw:{ polyline:{ shapeOptions:{ color:'#dc2626', weight:6, opacity:0.9 }},
             polygon:false, rectangle:false, circle:false, marker:false, circlemarker:false }
    });
    map.addControl(drawControl);

    // GPX Open/TRK/Trash
    let trkButtonRef = null, gpxTrackLayer = null, drawnRouteLayer = null;

    const GPXControl = L.Control.extend({
      options:{ position:'topleft' },
      onAdd:function(){
        const toolbar = L.DomUtil.create('div','gpx-toolbar leaflet-draw-toolbar leaflet-bar');
        L.DomEvent.disableClickPropagation(toolbar);

        // Open
        const openA = L.DomUtil.create('a','gpx-btn',toolbar); openA.textContent='Open';
        const fileInput = L.DomUtil.create('input','',toolbar);
        fileInput.type='file'; fileInput.accept='.gpx,application/gpx+xml,application/xml,text/xml'; fileInput.style.display='none';
        openA.onclick=(e)=>{ e.preventDefault(); fileInput.click(); };
        fileInput.onchange=(e)=>{ const f=e.target.files[0]; if(!f) return;
          const r=new FileReader(); r.onload=(evt)=>loadGPXFromText(evt.target.result,f.name); r.readAsText(f);
        };

        // TRK
        const listA = L.DomUtil.create('a','gpx-btn',toolbar); listA.textContent='TRK';
        listA.onclick=(e)=>{ e.preventDefault(); toggleListPanel(listA); };
        trkButtonRef = listA;

        // Trash
        const clearA = L.DomUtil.create('a','leaflet-draw-edit-remove',toolbar);
        clearA.title='Rensa GPX'; clearA.onclick=(e)=>{ e.preventDefault(); clearGpxTrack(); };

        return toolbar;
      }
    });
    map.addControl(new GPXControl());

    // GPS-knapp (följ-läge + heading-pil)
    const LocateControl = L.Control.extend({
      options:{ position:'topleft' },
      onAdd:function(){
        const div=L.DomUtil.create('div','leaflet-draw-toolbar leaflet-bar');
        const btn=L.DomUtil.create('a','gps-btn',div);
        btn.textContent='GPS'; btn.href='#'; btn.title='Följ min position';
        btn.onclick=(e)=>{ e.preventDefault(); toggleGPS(btn); };
        return div;
      }
    });
    map.addControl(new LocateControl());

    // Distans + export
    const distanceOutput = document.getElementById('distance-output');
    const exportBtn = document.getElementById('export-btn');

    function setDistanceKm(km){ distanceOutput.textContent = `${km.toFixed(2)} km`; }
    function computeLengthKmFromLatLngs(latlngs){
      if(!latlngs || latlngs.length<2) return 0;
      const line=L.polyline(latlngs).toGeoJSON(); return turf.length(line,{units:'kilometers'});
    }
    function updateExportState(){
      const ok=!!(drawnRouteLayer && drawnRouteLayer.getLatLngs().length>=2);
      exportBtn.disabled=!ok; exportBtn.onclick = ok ? ()=>exportToGPX(drawnRouteLayer.getLatLngs()) : null;
    }

    map.on(L.Draw.Event.DRAWSTART, (e)=>{ if(e.layerType==='polyline'){ setDistanceKm(0); exportBtn.disabled=true; exportBtn.onclick=null; }});
    map.on(L.Draw.Event.DRAWVERTEX, (e)=>{ const latlngs=[]; e.layers.eachLayer(m=>latlngs.push(m.getLatLng())); setDistanceKm(computeLengthKmFromLatLngs(latlngs)); });
    map.on(L.Draw.Event.CREATED, (e)=>{ if(e.layerType==='polyline'){ if(drawnRouteLayer) drawnItems.removeLayer(drawnRouteLayer); drawnRouteLayer=e.layer; drawnItems.addLayer(drawnRouteLayer); setDistanceKm(computeLengthKmFromLatLngs(drawnRouteLayer.getLatLngs())); updateExportState(); }});
    map.on(L.Draw.Event.EDITVERTEX, ()=>{ if(drawnRouteLayer){ setDistanceKm(computeLengthKmFromLatLngs(drawnRouteLayer.getLatLngs())); updateExportState(); }});
    map.on(L.Draw.Event.EDITED, ()=>{ if(drawnRouteLayer){ setDistanceKm(computeLengthKmFromLatLngs(drawnRouteLayer.getLatLngs())); updateExportState(); }});
    updateExportState();

    function exportToGPX(latlngs){
      if(!latlngs || latlngs.length<2) return;
      const now=new Date(); const isoNow=now.toISOString().split('.')[0]+'Z';
      const routeName=`Rutt_${new Date().toLocaleDateString('sv-SE')}_`+new Date().toLocaleTimeString('sv-SE',{hour12:false}).replace(/:/g,'-');
      let gpx=`<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="Ruttplan" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n  <metadata><name>${routeName}</name><time>${isoNow}</time></metadata>\n  <rte><name>${routeName}</name><time>${isoNow}</time>`;
      latlngs.forEach((p,i)=>{ gpx+=`\n    <rtept lat="${p.lat.toFixed(6)}" lon="${p.lng.toFixed(6)}"><name>P${i+1}</name></rtept>`; });
      gpx+=`\n  </rte>\n  <trk><name>${routeName}</name><trkseg>`;
      latlngs.forEach((p,i)=>{ const t=new Date(now.getTime()+i*1000).toISOString().split('.')[0]+'Z'; gpx+=`\n    <trkpt lat="${p.lat.toFixed(6)}" lon="${p.lng.toFixed(6)}"><time>${t}</time></trkpt>`; });
      gpx+=`\n    </trkseg></trk>\n</gpx>`;
      const blob=new Blob([gpx],{type:'application/gpx+xml'}); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=routeName.replace(/ /g,'_')+'.gpx'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    // GPX in/ut
    function attachGPXLayer(layer){ if(gpxTrackLayer) map.removeLayer(gpxTrackLayer); gpxTrackLayer=layer.addTo(map); layer.on('loaded',e=>{ map.fitBounds(e.target.getBounds()); const len=turf.length(e.target.toGeoJSON(),{units:'kilometers'}); setDistanceKm(len); }); }
    function loadGPXFromText(text){ attachGPXLayer(new L.GPX(text,{async:true})); }
    function loadGPXFromURL(url){ attachGPXLayer(new L.GPX(url,{async:true})); }
    function clearGpxTrack(){ if(gpxTrackLayer) map.removeLayer(gpxTrackLayer); gpxTrackLayer=null; if(!drawnRouteLayer) setDistanceKm(0); updateExportState(); }

    // TRK-lista
    const panel=document.getElementById('gpxListPanel'), listEl=document.getElementById('gpxList'), emptyEl=document.getElementById('gpxListEmpty');
    let loaded=false, outsideClickHandler=null;
    function toggleListPanel(anchorEl){
      if(panel.classList.contains('open')){ closeListPanel(); return; }
      const mapRect=map.getContainer().getBoundingClientRect(); const r=anchorEl.getBoundingClientRect();
      panel.style.top=`${r.top-mapRect.top}px`; panel.style.left=`${r.right-mapRect.left+8}px`;
      if(!loaded) loadTracksList(); panel.classList.add('open');
      outsideClickHandler=(ev)=>{ if(panel.contains(ev.target) || (anchorEl && anchorEl.contains(ev.target))) return; closeListPanel(); };
      document.addEventListener('click', outsideClickHandler);
    }
    function closeListPanel(){ panel.classList.remove('open'); if(outsideClickHandler){ document.removeEventListener('click', outsideClickHandler); outsideClickHandler=null; } }
    async function loadTracksList(){
      loaded=true; listEl.innerHTML=''; emptyEl.classList.add('hidden');
      try{
        const res=await fetch('gpx-tracks/manifest.json'); const files=await res.json();
        if(!Array.isArray(files)||files.length===0){ emptyEl.classList.remove('hidden'); return; }
        for(const file of files){ const url=`gpx-tracks/${file}`; const item=document.createElement('div'); item.className='gpx-list-item'; item.textContent=file; item.onclick=()=>{ loadGPXFromURL(url); closeListPanel(); }; listEl.appendChild(item); }
      }catch{ emptyEl.classList.remove('hidden'); }
    }
    window.addEventListener('resize',()=>{ if(panel.classList.contains('open') && trkButtonRef){ const mapRect=map.getContainer().getBoundingClientRect(); const r=trkButtonRef.getBoundingClientRect(); panel.style.top=`${r.top-mapRect.top}px`; panel.style.left=`${r.right-mapRect.left+8}px`; }});

    // GPS + heading (utan kartrotation)
    let watchId=null, following=false;
    let headingDeg=null, orientationActive=false;
    let smoothHeading=0, needFrame=false;

    function makeHeadingIcon(){
      return L.divIcon({
        className:'heading-marker heading-unknown',
        html:`<div class="arrow-wrap">
                 <svg class="arrow-svg" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                   <path class="fan" fill="#3b82f6" fill-opacity="0.18" d=""/>
                   <path d="M32 6 L42 28 L34 24 L34 56 L30 56 L30 24 L22 28 Z" fill="rgba(0,0,0,0.25)"/>
                   <path d="M32 6 L42 28 L34 24 L34 56 L30 56 L30 24 L22 28 Z" fill="#111827"/>
                 </svg>
               </div>
               <div class="dot"></div>`,
        iconSize:[28,28], iconAnchor:[14,14]
      });
    }
    let posMarker=null, accCircle=null;

    function toggleGPS(btn){
      following=!following; btn.classList.toggle('gps-active', following);
      if(following){ startGeolocation(); ensureOrientation(); }
      else{ stopGeolocation(); disableOrientation(); }
    }
    function startGeolocation(){
      if(!navigator.geolocation) return alert('Geolocation stöds inte i denna webbläsare.');
      watchId = navigator.geolocation.watchPosition(onPosition, onPositionError, { enableHighAccuracy:true, timeout:15000, maximumAge:0 });
    }
    function stopGeolocation(){ if(watchId!==null){ navigator.geolocation.clearWatch(watchId); watchId=null; } }
    function onPosition(pos){
      const { latitude, longitude, accuracy } = pos.coords; const ll=[latitude, longitude];
      if(!posMarker){ posMarker=L.marker(ll,{icon:makeHeadingIcon(), interactive:false}).addTo(map); } else { posMarker.setLatLng(ll); }
      if(!accCircle){ accCircle=L.circle(ll,{radius:accuracy,color:'#3b82f6',weight:1,fillColor:'#60a5fa',fillOpacity:0.15,interactive:false}).addTo(map); } else { accCircle.setLatLng(ll).setRadius(accuracy); }
      if(following){ map.setView(ll, Math.max(map.getZoom(), 15), {animate:true}); }
      queueFrame();
    }
    function onPositionError(err){ console.warn('Geolocation error:', err); }

    function ensureOrientation(){
      const needIOS = typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function';
      if(needIOS){ DeviceOrientationEvent.requestPermission().then(s=>{ if(s==='granted') startOrientation(); }).catch(()=>{}); } else { startOrientation(); }
    }
    function startOrientation(){ if(orientationActive) return; orientationActive=true; window.addEventListener('deviceorientation', onOrientation, true); window.addEventListener('deviceorientationabsolute', onOrientation, true); }
    function disableOrientation(){ orientationActive=false; }
    function onOrientation(e){
      const screenAngle=(screen.orientation && typeof screen.orientation.angle==='number')?screen.orientation.angle:0;
      if(typeof e.webkitCompassHeading==='number'){ headingDeg = normalize(e.webkitCompassHeading); }
      else if(typeof e.alpha==='number'){ let h=360 - e.alpha; h -= screenAngle; headingDeg = normalize(h); }
      else { headingDeg = null; }
      queueFrame();
    }

    function normalize(a){ a=a%360; if(a<0) a+=360; return a; }
    function shortest(a,b){ let d=(b-a+540)%360-180; return d; }
    function smoothTo(cur,tgt,k){ const d=shortest(cur,tgt); return normalize(cur + d*k); }

    function queueFrame(){ if(needFrame) return; needFrame=true; requestAnimationFrame(tick); }
    function tick(){ needFrame=false; updateHeading(); }

    function updateHeading(){
      if(!posMarker) return;
      const el=posMarker.getElement(); if(!el) return;
      const wrap=el.querySelector('.arrow-wrap'); if(!wrap) return;
      const target = headingDeg ?? 0;
      smoothHeading = smoothTo(smoothHeading, target, 0.15);
      wrap.style.transform = `rotate(${smoothHeading}deg)`;
    }
  });
  </script>
</body>
</html>
