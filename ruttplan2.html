<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <title>Kartl√§ggare ‚Äì MapLibre GL (stabil ROT + GPX)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Tailwind f√∂r UI -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- MapLibre -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- Turf (distans m.m.) -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- togeojson (GPX -> GeoJSON) -->
  <script src="https://unpkg.com/@tmcw/togeojson/dist/togeojson.umd.js"></script>

  <style>
    html, body { height: 100%; margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #map { position: absolute; inset: 0; }

    /* Distans + Export uppe till v√§nster */
    #info-panel { position: absolute; top: 10px; left: 56px; z-index: 10; }

    /* V√§nster verktygsrad (under MapLibre-zoom) */
    .left-toolbar {
      position: absolute;
      top: 94px;      /* under zoomknapparna */
      left: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
    }
    .tool-btn {
      width: 30px; height: 30px;
      display:flex; align-items:center; justify-content:center;
      background:#fff; border:1px solid #ccc; border-bottom:none;
      color:#464646; font-size:10px; font-weight:400;
      cursor:pointer; user-select:none;
    }
    .tool-btn:last-child { border-bottom: 1px solid #ccc; }
    .tool-btn:hover { background:#f4f4f4; }
    .tool-active { outline:2px solid #60a5fa; outline-offset:-1px; }
    .rot-active { outline:2px solid #34d399; outline-offset:-1px; }

    /* TRK-lista */
    .tracks-panel {
      position: absolute; z-index: 12; background: #fff; width: 260px; border-radius: .25rem;
      box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.1);
      display: none; max-height: 75vh; overflow: auto;
    }
    .tracks-panel.open { display: block; }
    .trk-item { padding: 8px 10px; cursor: pointer; }
    .trk-item:hover { background: #f3f4f6; }
  </style>
</head>
<body>

  <div id="map"></div>

  <!-- Distans + Export -->
  <div id="info-panel">
    <div class="flex items-center gap-3 bg-white/95 backdrop-blur px-4 py-2 rounded-full shadow">
      <span class="text-sm text-red-600 font-bold" id="distance-output">0.00 km</span>
      <button id="export-btn" disabled
        class="px-4 py-1.5 rounded-full text-sm font-semibold text-white bg-black disabled:opacity-50 disabled:cursor-not-allowed">
        Export
      </button>
    </div>
  </div>

  <!-- V√§nster verktygsrad -->
  <div class="left-toolbar" id="leftToolbar">
    <div class="tool-btn" id="btnOpen">Open</div>
    <div class="tool-btn" id="btnTRK">TRK</div>
    <div class="tool-btn" id="btnTrash" title="Rensa sp√•r">üóë</div>
    <div class="tool-btn" id="btnGPS">GPS</div>
    <div class="tool-btn" id="btnROT">ROT</div>
    <div class="tool-btn" id="btnCal" title="Heading offset">0</div>
    <div class="tool-btn" id="btnRings" title="25/50/100 m">RNG</div>
    <div class="tool-btn" id="btnDraw" title="Rita rutt">Draw</div>
  </div>

  <!-- TRK-lista -->
  <div id="tracksPanel" class="tracks-panel">
    <div class="px-3 py-2 text-sm font-semibold border-b border-gray-200">F√∂rdefinierade sp√•r</div>
    <div id="trkList"></div>
  </div>

  <!-- Filinput f√∂r Open -->
  <input type="file" id="fileInput" accept=".gpx,application/gpx+xml,application/xml,text/xml" style="display:none" />

  <script>
  (async function () {
    // ======================
    // ===== KONFIG ========
    // ======================
    const MAX_ZOOM = 17;
    const START = { lat: 56.15666, lng: 15.84580, zoom: 15 };

    // Bas/overlay rasterk√§llor
    const OSM_URL   = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
    const ESRI_URL  = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
    const ORION_URL = 'https://api.maptiler.com/tiles/019a970d-bbd1-7b91-8965-56a0ed1f7359/{z}/{x}/{y}.png?key=oLez5PJEfDrQfYbX7BZM';
    //const ORION_URL = 'https://okorion.com/maptiles/orienteering/wgs84/{z}/{x}/{y}.png';

    // ROT-parametrar
    const HEADING_FLIP = -1;      // flippa kompassriktning (enligt din observation)
    let HEADING_CAL_OFFSET = 0;   // justerbar via knapp (0..360 i 45¬∞-steg)
    const MEDIAN_N = 7;           // storlek p√• medianf√∂nster (udda tal)
    const HEADING_LPF = 0.10;     // l√•gpass 0..1 (h√∂gre = snabbare, mer jitter)
    const BEARING_STEP_DEG = 2;   // max bearing√§ndring per frame
    const BEARING_EPS = 0.15;     // n√§rme-tr√∂skel

    // ======================
    // ===== STYLE =========
    // ======================
    const style = {
      "version": 8,
      "name": "Raster base",
      "sources": {
        "osm":  { "type":"raster", "tiles":[OSM_URL],  "tileSize":256, "maxzoom": MAX_ZOOM, "attribution":"¬© OpenStreetMap-bidragsgivare" },
        "esri": { "type":"raster", "tiles":[ESRI_URL], "tileSize":256, "maxzoom": MAX_ZOOM, "attribution":"Imagery ¬© Esri, Maxar, Earthstar Geographics" },
        "orion":{ "type":"raster", "tiles":[ORION_URL],"tileSize":256, "maxzoom": MAX_ZOOM, "attribution":"¬© OK Orion - Rendered with MapTiler Engine, non-commercial use only " } 
      },
      "layers": [
        { "id":"osm",   "type":"raster", "source":"osm",   "layout":{"visibility":"visible"} },
        { "id":"esri",  "type":"raster", "source":"esri",  "layout":{"visibility":"none"} },
        { "id":"orion", "type":"raster", "source":"orion", "layout":{"visibility":"visible"} }
      ]
    };

    // ======================
    // ===== KARTA =========
    // ======================
    const map = new maplibregl.Map({
      container: 'map',
      style,
      center: [START.lng, START.lat],
      zoom: START.zoom,
      pitch: 0,
      bearing: 0,
      dragRotate: false,
      maxZoom: MAX_ZOOM
    });
    map.addControl(new maplibregl.NavigationControl({ showCompass: false }), 'top-left');

    // ===== Baslager-v√§xling (exponera vid behov) =====
    function setBase(base) {
      map.setLayoutProperty('osm',  'visibility', base === 'osm'  ? 'visible' : 'none');
      map.setLayoutProperty('esri', 'visibility', base === 'esri' ? 'visible' : 'none');
    }

    // ============================
    // ===== K√ÑLLOR/LAGER =========
    // ============================
    const drawSourceId = 'draw-line-src';
    const drawLayerId  = 'draw-line-lyr';
    const drawPointsId = 'draw-points-src';
    const drawPointsLy = 'draw-points-lyr';

    const gpxSrcId = 'gpx-src';
    const gpxLyId  = 'gpx-lyr';

    const posSrcId  = 'pos-src';
    const accSrcId  = 'acc-src';
    const posLyId   = 'pos-lyr';
    const accLyId   = 'acc-lyr';

    const ringsSrcId = 'rings-src';
    const ringsLyId  = 'rings-lyr';

    // Tillst√•nd/UI-refs
    let isDrawing = false;
    let drawCoords = [];
    let gpxShown = false;
    let followOn = false;
    let rotOn = false;
    let watchId = null;
    let lastLL = null;
    let ringsOn = false;

    const btnOpen  = document.getElementById('btnOpen');
    const btnTRK   = document.getElementById('btnTRK');
    const btnTrash = document.getElementById('btnTrash');
    const btnGPS   = document.getElementById('btnGPS');
    const btnROT   = document.getElementById('btnROT');
    const btnRings = document.getElementById('btnRings');
    const btnCal   = document.getElementById('btnCal');
    const btnDraw  = document.getElementById('btnDraw');
    const exportBtn = document.getElementById('export-btn');
    const distanceOutput = document.getElementById('distance-output');
    const fileInput = document.getElementById('fileInput');
    const tracksPanel = document.getElementById('tracksPanel');
    const trkList = document.getElementById('trkList');

    function setDistanceKm(km) { distanceOutput.textContent = `${km.toFixed(2)} km`; }
    function computeLengthKmFromCoords(coords) {
      if (!coords || coords.length < 2) return 0;
      const gj = { type: 'Feature', geometry: { type: 'LineString', coordinates: coords }, properties: {} };
      return turf.length(gj, { units: 'kilometers' });
    }
    function refreshExportState() {
      const ok = drawCoords.length >= 2;
      exportBtn.disabled = !ok;
      exportBtn.onclick = ok ? () => exportToGPX(drawCoords) : null;
    }

    map.on('load', () => {
      // Init text f√∂r offset-knapp
      if (btnCal) btnCal.textContent = String(HEADING_CAL_OFFSET);
      // Rita ‚Äì linje + punkter
      map.addSource(drawSourceId, { type:'geojson', data: emptyFC() });
      map.addLayer({ id: drawLayerId, type:'line', source: drawSourceId,
        paint:{ 'line-color':'#dc2626', 'line-width':4, 'line-opacity':0.9 }});
      map.addSource(drawPointsId, { type:'geojson', data: emptyFC() });
      map.addLayer({ id: drawPointsLy, type:'circle', source: drawPointsId,
        paint:{ 'circle-color':'#dc2626', 'circle-radius':3, 'circle-stroke-color':'#ffffff', 'circle-stroke-width':1 }});

      // GPX
      map.addSource(gpxSrcId, { type:'geojson', data: emptyFC() });
      map.addLayer({ id: gpxLyId, type:'line', source: gpxSrcId,
        paint:{ 'line-color':'#0ea5e9', 'line-width':3, 'line-opacity':0.9 }});

      // Position
      map.addSource(posSrcId, { type:'geojson', data: emptyFC() });
      map.addLayer({ id: posLyId, type:'circle', source: posSrcId,
        paint:{ 'circle-color':'#3b82f6', 'circle-radius':6, 'circle-stroke-color':'#ffffff', 'circle-stroke-width':2 }});

      // Noggrannhetscirkel
      map.addSource(accSrcId, { type:'geojson', data: emptyFC() });
      map.addLayer({ id: accLyId, type:'fill', source: accSrcId,
        paint:{ 'fill-color':'#60a5fa', 'fill-opacity':0.15, 'fill-outline-color':'#3b82f6' }});

      // R√§ckviddsringar (25/50/100 m)
      map.addSource(ringsSrcId, { type:'geojson', data: emptyFC() });
      map.addLayer({ id: ringsLyId, type:'line', source: ringsSrcId,
        layout:{ visibility:'none' },
        paint:{ 'line-color':'#dc2626', 'line-width':2, 'line-dasharray':[2,2] }});

      // Rita: klick l√§gger punkt, dblclick avslutar
      map.on('click', (e) => {
        if (!isDrawing) return;
        drawCoords.push([e.lngLat.lng, e.lngLat.lat]);
        updateDrawLayers();
        setDistanceKm(computeLengthKmFromCoords(drawCoords));
        refreshExportState();
      });
      map.on('dblclick', () => {
        if (!isDrawing) return;
        isDrawing = false;
        btnDraw.classList.remove('tool-active');
      });

      // Pausa bearing-loop under manuell interaktion (mindre glitch)
      map.on('movestart', stopBearingLoop);
      map.on('moveend', () => { if (rotOn) startBearingLoop(); });

      refreshExportState();

      // ======================
      // Sm√• "testfall" f√∂r snabb sanity-check (icke-destruktiva)
      // ======================
      try {
        // Test 1: updateRings ska inte kasta fel och s√§tta GeoJSON korrekt
        const llTest = [START.lng, START.lat];
        updateRings(llTest);
        console.info('[TEST] updateRings OK');
      } catch (e) {
        console.error('[TEST] updateRings FAIL', e);
      }
      try {
        // Test 2: 8 steg om 45¬∞ ska wrap:a tillbaka till startv√§rdet (utan att mutera globalen)
        const start = HEADING_CAL_OFFSET;
        let v = start;
        for (let i = 0; i < 8; i++) v = (v + 45) % 360;
        console[(v === start) ? 'info' : 'error']('[TEST] offset wrap', { start, end: v });
      } catch (e) {
        console.error('[TEST] offset wrap FAIL', e);
      }
    });

    function emptyFC(){ return { type:'FeatureCollection', features:[] }; }

    function updateDrawLayers(){
      const lineFC = drawCoords.length >= 2
        ? { type:'FeatureCollection', features:[{ type:'Feature', properties:{}, geometry:{ type:'LineString', coordinates: drawCoords } }] }
        : emptyFC();
      map.getSource(drawSourceId).setData(lineFC);

      const pts = drawCoords.map(c => ({ type:'Feature', properties:{}, geometry:{ type:'Point', coordinates:c } }));
      map.getSource(drawPointsId).setData({ type:'FeatureCollection', features: pts });
    }

    // ===== Export GPX =====
    function exportToGPX(coords){
      if (!coords || coords.length < 2) return;
      const now = new Date();
      const isoNow = now.toISOString().split('.')[0] + 'Z';
      const routeName = `Rutt_${now.toLocaleDateString('sv-SE')}_${now.toLocaleTimeString('sv-SE', {hour12:false}).replace(/:/g,'-')}`;
      let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1"
     creator="Ruttplan-MapLibre"
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1
                         http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata><name>${routeName}</name><time>${isoNow}</time></metadata>
  <rte><name>${routeName}</name><time>${isoNow}</time>`;
      coords.forEach((c,i)=>{ gpx += `\n    <rtept lat="${c[1].toFixed(6)}" lon="${c[0].toFixed(6)}"><name>P${i+1}</name></rtept>`; });
      gpx += `
  </rte>
  <trk><name>${routeName}</name><trkseg>`;
      coords.forEach((c,i)=>{ const t = new Date(now.getTime()+i*1000).toISOString().split('.')[0]+'Z';
        gpx += `\n    <trkpt lat="${c[1].toFixed(6)}" lon="${c[0].toFixed(6)}"><time>${t}</time></trkpt>`; });
      gpx += `
    </trkseg></trk>
</gpx>`;
      const blob = new Blob([gpx], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url;
      a.download = routeName.replace(/ /g,'_') + '.gpx';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ===== Open (lokal GPX) =====
    btnOpen.onclick = () => fileInput.click();
    fileInput.onchange = async (e) => {
      const file = e.target.files[0]; if (!file) return;
      const text = await file.text(); showGpxText(text);
    };

    // ===== TRK (manifest) =====
    btnTRK.onclick = (e) => { e.preventDefault(); toggleTracksPanel(btnTRK); };
    function toggleTracksPanel(anchorBtn){
      const panel = document.getElementById('tracksPanel');
      if (panel.classList.contains('open')) { panel.classList.remove('open'); return; }
      positionPanelRightOf(anchorBtn);
      populateTracksList(panel);
      panel.classList.add('open');
      const closeOnOutside = (ev) => {
        if (!panel.contains(ev.target) && ev.target !== anchorBtn) {
          panel.classList.remove('open'); document.removeEventListener('click', closeOnOutside);
        }
      };
      setTimeout(()=>document.addEventListener('click', closeOnOutside),0);
    }
    function positionPanelRightOf(anchorBtn){
      const panel = document.getElementById('tracksPanel');
      const mapRect = map.getContainer().getBoundingClientRect();
      const r = anchorBtn.getBoundingClientRect();
      panel.style.top = `${r.top - mapRect.top}px`;
      panel.style.left = `${r.right - mapRect.left + 8}px`;
    }
    async function populateTracksList(panel){
      const list = document.getElementById('trkList');
      list.innerHTML = '';
      try{
        const res = await fetch('gpx-tracks/manifest.json');
        const files = await res.json();
        if (!Array.isArray(files) || files.length === 0) {
          list.innerHTML = `<div class="p-3 text-xs text-gray-500">Inga sp√•r funna.</div>`;
          return;
        }
        files.forEach((f)=>{
          const item = document.createElement('div');
          item.className = 'trk-item';
          item.textContent = f;
          item.onclick = async () => {
            const url = `gpx-tracks/${f}`;
            const txt = await (await fetch(url)).text();
            showGpxText(txt);
            panel.classList.remove('open');
          };
          list.appendChild(item);
        });
      }catch{
        list.innerHTML = `<div class="p-3 text-xs text-red-600">Kunde inte l√§sa manifest.json</div>`;
      }
    }

    // ===== Trash =====
    btnTrash.onclick = () => {
      map.getSource(gpxSrcId).setData(emptyFC());
      gpxShown = false;
      if (drawCoords.length === 0) setDistanceKm(0);
    };

    // ===== Draw =====
    btnDraw.onclick = () => {
      isDrawing = !isDrawing;
      btnDraw.classList.toggle('tool-active', isDrawing);
      if (isDrawing) {
        drawCoords = [];
        updateDrawLayers();
        setDistanceKm(0);
        refreshExportState();
      }
    };

    // ===== GPS =====
    btnGPS.onclick = () => {
      followOn = !followOn;
      btnGPS.classList.toggle('tool-active', followOn);
      if (followOn) startGeolocation();
      else stopGeolocation();
    };

    // ===== CAL (heading offset 45¬∞-steg) =====
    btnCal.onclick = () => {
      HEADING_CAL_OFFSET = (HEADING_CAL_OFFSET + 45) % 360;
      btnCal.textContent = String(HEADING_CAL_OFFSET);
      // om ROT √§r p√•, trigga en snabb uppdatering genom att k√∂ra bearing-step direkt
      if (rotOn) scheduleBearingStep();
    };

    // ===== RINGS (25/50/100 m) =====
    btnRings.onclick = () => {
      ringsOn = !ringsOn;
      btnRings.classList.toggle('tool-active', ringsOn);
      map.setLayoutProperty(ringsLyId, 'visibility', ringsOn ? 'visible' : 'none');
      if (ringsOn && lastLL) updateRings(lastLL);
    };

    function updateRings(ll) {
      const radii = [25,50,100];
      const features = radii.map(r => turf.circle(ll, r, { steps: 128, units: 'meters' }));
      map.getSource(ringsSrcId).setData({ type:'FeatureCollection', features });
    }

    function startGeolocation(){
      if (!navigator.geolocation) { alert('Geolocation saknas.'); return; }
      watchId = navigator.geolocation.watchPosition(onPosition, onPositionError, {
        enableHighAccuracy: true, timeout: 15000, maximumAge: 0
      });
      ensureOrientation(); // f√∂r ROT
    }
    function stopGeolocation(){
      if (watchId != null) { navigator.geolocation.clearWatch(watchId); watchId = null; }
      if (!rotOn) disableOrientation();
    }
    function onPosition(pos){
      const { latitude, longitude, accuracy } = pos.coords;
      const ll = [longitude, latitude];
      lastLL = ll;

      // Position
      map.getSource(posSrcId).setData({
        type:'FeatureCollection',
        features:[{ type:'Feature', properties:{}, geometry:{ type:'Point', coordinates: ll } }]
      });

      // Noggrannhet (polygon)
      const accPoly = turf.circle(ll, Math.max(accuracy || 10, 5), { steps: 64, units: 'meters' });
      map.getSource(accSrcId).setData(accPoly);

      // Uppdatera ringar om p√•slaget
      if (ringsOn) updateRings(ll);

      if (followOn || rotOn) {
        map.easeTo({ center: ll, duration: 300, zoom: Math.max(map.getZoom(), 15) });
      }
    }
    function onPositionError(err){ console.warn('Geolocation error', err); }

    // ===== ROT (track-up) =====
    btnROT.onclick = () => {
      rotOn = !rotOn;
      btnROT.classList.toggle('rot-active', rotOn);
      if (rotOn) {
        ensureOrientation();
        if (lastLL) map.jumpTo({ center: lastLL, zoom: Math.max(map.getZoom(), 15) });
        startBearingLoop();
      } else {
        stopBearingLoop();
        desiredBearing = 0;
        filteredHeading = 0;
        headingRing.length = 0;
        map.easeTo({ bearing: 0, duration: 300 });
        if (!followOn) disableOrientation();
      }
    };

    // ===== Heading / Bearing stabilisering =====
    let orientationOn = false;
    let useSensor = false;
    let desiredBearing = 0;
    let filteredHeading = 0;             // LPF-utg√•ng
    const headingRing = [];              // f√∂r median
    let rafId = 0;

    function ensureOrientation(){
      // F√∂rs√∂k Web Sensors API f√∂rst
      tryStartAbsoluteSensor();
      if (!useSensor) {
        // Fallback: DeviceOrientation
        const needIOS = typeof DeviceOrientationEvent !== 'undefined' &&
                        typeof DeviceOrientationEvent.requestPermission === 'function';
        if (needIOS) {
          DeviceOrientationEvent.requestPermission()
            .then(state => { if (state === 'granted') startDeviceOrientation(); })
            .catch(()=>{});
        } else startDeviceOrientation();
      }
    }

    function startDeviceOrientation(){
      if (orientationOn) return;
      orientationOn = true;
      window.addEventListener('deviceorientation', onDeviceOrientation, true);
      window.addEventListener('deviceorientationabsolute', onDeviceOrientation, true);
    }
    function disableOrientation(){ orientationOn = false; /* beh√•ll listeners ‚Äì l√•g overhead */ }

    function tryStartAbsoluteSensor(){
      try {
        const sensor = new AbsoluteOrientationSensor({ frequency: 30, referenceFrame: 'device' });
        sensor.addEventListener('reading', () => {
          // quaternion -> yaw (Z) i grader
          const [qx, qy, qz, qw] = sensor.quaternion;
          const siny_cosp = 2 * (qw*qz + qx*qy);
          const cosy_cosp = 1 - 2 * (qy*qy + qz*qz);
          let yaw = Math.atan2(siny_cosp, cosy_cosp) * 180 / Math.PI; // -180..180
          if (yaw < 0) yaw += 360;

          const screenAngle = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : 0;
          // Kompasskurs ~ 0=norr, medurs: 360 - yaw
          let heading = (360 - yaw + screenAngle) % 360;
          processHeading(heading);
        });
        sensor.addEventListener('error', () => { useSensor = false; });
        sensor.start();
        useSensor = true;
      } catch (e) {
        useSensor = false;
      }
    }

    function onDeviceOrientation(e){
      if (!orientationOn) return;
      const screenAngle = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : 0;

      let heading = null;
      if (typeof e.webkitCompassHeading === 'number' && e.webkitCompassHeading >= 0) {
        // iOS: world-referenced (0=norr, medurs)
        heading = e.webkitCompassHeading;
      } else if (typeof e.alpha === 'number') {
        // Android: anv√§nd -alpha (motsatt) + sk√§rmrotation
        heading = (-e.alpha + screenAngle) % 360;
        if (heading < 0) heading += 360;
      }
      if (heading == null) return;

      processHeading(heading);
    }

    function normalizeDeg(a){ a = a % 360; if (a < 0) a += 360; return a; }
    function shortestDelta(a, b){ return (b - a + 540) % 360 - 180; }

    function pushMedian(h){
      headingRing.push(h);
      if (headingRing.length > MEDIAN_N) headingRing.shift();

      // ‚Äúcirkul√§r median‚Äù via vektormedel (ger robust resultat)
      const vec = headingRing.map(a => [Math.cos(a*Math.PI/180), Math.sin(a*Math.PI/180)]);
      const sx = vec.reduce((s,v)=>s+v[0],0), sy = vec.reduce((s,v)=>s+v[1],0);
      let ang = Math.atan2(sy, sx)*180/Math.PI; if (ang < 0) ang += 360;
      return ang;
    }

    function processHeading(raw){
      // flip + offset
      let h = normalizeDeg(HEADING_FLIP * raw + HEADING_CAL_OFFSET);

      // median
      h = pushMedian(h);

      // l√•gpass
      const d = shortestDelta(filteredHeading, h);
      filteredHeading = normalizeDeg(filteredHeading + d * HEADING_LPF);

      // vi vill att kartan roterar "under" anv√§ndaren s√• att pilen pekar upp√•t
      desiredBearing = normalizeDeg(-filteredHeading);

      if (rotOn) scheduleBearingStep();
    }

    function scheduleBearingStep(){
      if (rafId) return;
      rafId = requestAnimationFrame(applyBearingStep);
    }
    function applyBearingStep(){
      rafId = 0;
      const current = map.getBearing();
      const delta = shortestDelta(current, desiredBearing);

      if (Math.abs(delta) < BEARING_EPS) return;

      const step = Math.sign(delta) * Math.min(Math.abs(delta), BEARING_STEP_DEG);
      const next = current + step;

      // undvik blink/easing-loopar
      map.jumpTo({ bearing: next });

      // forts√§tt tills vi √§r n√§ra
      rafId = requestAnimationFrame(applyBearingStep);
    }
    function startBearingLoop(){ scheduleBearingStep(); }
    function stopBearingLoop(){ if (rafId) { cancelAnimationFrame(rafId); rafId = 0; } }

    // ===== Visa GPX =====
    function showGpxText(gpxText){
      try{
        const parser = new DOMParser();
        const xml = parser.parseFromString(gpxText, 'application/xml');
        const gj = toGeoJSON.gpx(xml);
        const lineFeatures = [];
        (gj.features || []).forEach(f=>{
          if (!f.geometry) return;
          if (f.geometry.type === 'LineString') lineFeatures.push(f);
          if (f.geometry.type === 'MultiLineString') {
            f.geometry.coordinates.forEach(coords=>{
              lineFeatures.push({ type:'Feature', properties:f.properties||{}, geometry:{ type:'LineString', coordinates: coords } });
            });
          }
        });
        const fc = { type:'FeatureCollection', features: lineFeatures };
        map.getSource(gpxSrcId).setData(fc);
        gpxShown = lineFeatures.length > 0;

        if (gpxShown) {
          const bbox = turf.bbox(fc);
          map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { padding: 40, maxZoom: MAX_ZOOM });
          // total distans
          let total = 0;
          lineFeatures.forEach(f => total += turf.length(f, { units:'kilometers' }));
          setDistanceKm(total);
        } else {
          if (drawCoords.length === 0) setDistanceKm(0);
        }
      }catch(err){ console.error('Kunde inte tolka GPX:', err); }
    }

    // ===== Open / TRK =====
    btnOpen.onclick = () => fileInput.click();
    fileInput.onchange = async (e) => {
      const file = e.target.files[0]; if (!file) return;
      const text = await file.text(); showGpxText(text);
    };

    btnTRK.onclick = (e) => { e.preventDefault(); toggleTracksPanel(btnTRK); };
    function toggleTracksPanel(anchorBtn){
      const panel = document.getElementById('tracksPanel');
      if (panel.classList.contains('open')) { panel.classList.remove('open'); return; }
      positionPanelRightOf(anchorBtn);
      populateTracksList(panel);
      panel.classList.add('open');
      const closeOnOutside = (ev) => {
        if (!panel.contains(ev.target) && ev.target !== anchorBtn) {
          panel.classList.remove('open'); document.removeEventListener('click', closeOnOutside);
        }
      };
      setTimeout(()=>document.addEventListener('click', closeOnOutside),0);
    }
    function positionPanelRightOf(anchorBtn){
      const panel = document.getElementById('tracksPanel');
      const mapRect = map.getContainer().getBoundingClientRect();
      const r = anchorBtn.getBoundingClientRect();
      panel.style.top = `${r.top - mapRect.top}px`;
      panel.style.left = `${r.right - mapRect.left + 8}px`;
    }
    async function populateTracksList(panel){
      const list = document.getElementById('trkList');
      list.innerHTML = '';
      try{
        const res = await fetch('gpx-tracks/manifest.json');
        const files = await res.json();
        if (!Array.isArray(files) || files.length === 0) {
          list.innerHTML = `<div class="p-3 text-xs text-gray-500">Inga sp√•r funna.</div>`;
          return;
        }
        files.forEach((f)=>{
          const item = document.createElement('div');
          item.className = 'trk-item';
          item.textContent = f;
          item.onclick = async () => {
            const url = `gpx-tracks/${f}`;
            const txt = await (await fetch(url)).text();
            showGpxText(txt);
            panel.classList.remove('open');
          };
          list.appendChild(item);
        });
      }catch{
        list.innerHTML = `<div class="p-3 text-xs text-red-600">Kunde inte l√§sa manifest.json</div>`;
      }
    }

    // Init
    setDistanceKm(0);
  })();
  </script>
</body>
</html>
