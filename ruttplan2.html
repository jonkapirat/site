<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Rotator</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet + Draw CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css">

  <style>
    body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
    #map { height: 100vh; width: 100vw; background: #fff; }

    /* Distans + export “pill” uppe till vänster, strax höger om + */
    #info-panel { position: absolute; top: 10px; left: 56px; }
    .leaflet-control-container .leaflet-draw {
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }
    .gpx-toolbar.leaflet-draw-toolbar.leaflet-bar { margin-top: 4px; }

    /* Dropdown för fördefinierade spår */
    .gpx-list-panel {
      position: absolute;
      z-index: 1000;
      background: #fff;
      border-radius: 0.25rem;
      box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.1);
      width: 240px; overflow: hidden; display: none;
    }
    .gpx-list-panel.open { display: block; }
    .gpx-list-item { padding: 8px 10px; cursor: pointer; }
    .gpx-list-item:hover { background: #f3f4f6; }

    /* Vänster verktygsrad – textknappar som matchar Leaflet */
    .leaflet-draw-toolbar .gpx-btn,
    .leaflet-draw-toolbar .gps-btn,
    .leaflet-draw-toolbar .rot-btn {
      width: 30px; height: 30px;
      display: flex; align-items: center; justify-content: center;
      background-color: #fff;
      border: 1px solid #ccc; border-bottom: none;
      color: #464646; font-size: 10px; font-weight: 400;
      line-height: 30px; text-decoration: none; cursor: pointer; box-sizing: border-box;
      background-image: none !important;
    }
    .leaflet-draw-toolbar .gpx-btn:last-of-type,
    .leaflet-draw-toolbar .gps-btn:last-of-type,
    .leaflet-draw-toolbar .rot-btn:last-of-type { border-bottom: 1px solid #ccc; }
    .leaflet-draw-toolbar .gpx-btn:hover,
    .leaflet-draw-toolbar .gps-btn:hover,
    .leaflet-draw-toolbar .rot-btn:hover { background-color: #f4f4f4; }
    .gps-active { outline: 2px solid #60a5fa; outline-offset: -1px; }
    .rot-active { outline: 2px solid #34d399; outline-offset: -1px; }

    /* Positionsmarkör: blå punkt + pil + fan (SVG) */
    .heading-marker { position: relative; width: 28px; height: 28px; }
    .heading-marker .dot {
      width: 12px; height: 12px; background: #3b82f6;
      border: 2px solid #fff; border-radius: 50%;
      position: absolute; top: 8px; left: 8px; box-shadow: 0 0 4px rgba(0,0,0,0.25); z-index: 2;
    }
    .heading-marker .arrow-wrap {
      position: absolute; top: -2px; left: -2px;
      width: 32px; height: 32px;
      transform-origin: 50% 50%;
      will-change: transform;
      z-index: 1;
    }
    .heading-marker .arrow-svg { width: 32px; height: 32px; display: block; }
    .heading-unknown .arrow-wrap { opacity: 0.45; }

    /* Egen rotator-wrapper för karta – vi roterar DEN, inte Leaflets egna transforms */
    .bearing-rotator {
      transform-origin: 50% 50%;
      backface-visibility: hidden;
      will-change: transform;
      contain: paint;
      pointer-events: none; /* släpp igenom interaktion */
    }
    .bearing-rotator > .leaflet-tile-pane,
    .bearing-rotator > .leaflet-overlay-pane {
      pointer-events: auto; /* men låt panes få events */
    }
  </style>
</head>
<body>

  <div id="map"></div>

  <!-- Distans + Export -->
  <div id="info-panel" class="z-[1000]">
    <div class="flex items-center gap-3 bg-white/95 backdrop-blur px-4 py-2 rounded-full shadow">
      <span class="text-sm text-red-600 font-bold" id="distance-output">0.00 km</span>
      <button id="export-btn" disabled
        class="px-4 py-1.5 rounded-full text-sm font-semibold text-white bg-black disabled:opacity-50 disabled:cursor-not-allowed">
        Export
      </button>
    </div>
  </div>

  <!-- Dropdown för fördefinierade spår -->
  <div id="gpxListPanel" class="gpx-list-panel">
    <div class="px-3 py-2 text-sm font-semibold border-b border-gray-200">Fördefinierade spår</div>
    <div id="gpxList" class="max-h-72 overflow-auto"></div>
    <div id="gpxListEmpty" class="p-3 text-xs text-gray-500 hidden">
      Hittade inga spår. Säkerställ att <code>gpx-tracks/manifest.json</code> finns.
    </div>
  </div>

  <!-- Libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>

  <script>
  document.addEventListener('DOMContentLoaded', function () {
    const MAX_ZOOM = 17; // ändra här om du vill testa annat maxzoom
    const START = { lat: 56.15666, lng: 15.84580, zoom: 15 };

    // === Heading/rotator config ===
    const DEFAULT_FAN_DEG = 60, MIN_FAN_DEG = 20, MAX_FAN_DEG = 120;
    const FAN_FILL = '#3b82f6', FAN_OPACITY = 0.18;
    const HEADING_SMOOTH = 0.15;   // 0..1 (högre = snabbare)
    const ROT_SCALE = 1.03;        // dölja tile-kanter vid rotation

    // === Baslager ===
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      noWrap: true, maxZoom: MAX_ZOOM, attribution: '© OpenStreetMap-bidragsgivare'
    });
    const esriSat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { noWrap: true, maxZoom: MAX_ZOOM, attribution: 'Imagery © Esri, Maxar, Earthstar Geographics' }
    );
    const orionOverlay = L.tileLayer(
      'https://okorion.com/maptiles/orienteering/wgs84/{z}/{x}/{y}.png',
      { noWrap: true, maxZoom: MAX_ZOOM, attribution: '© OK Orion', opacity: 1.0 }
    );

    const map = L.map('map', { center: [START.lat, START.lng], zoom: START.zoom, layers: [osm, orionOverlay] });

    L.control.layers(
      { 'OpenStreetMap (bas)': osm, 'Satellit (Esri World Imagery)': esriSat },
      { 'OK Orion (överlagrat)': orionOverlay },
      { position: 'topright' }
    ).addTo(map);

    // === Ritverktyg ===
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
    const drawControl = new L.Control.Draw({
      position: 'topleft',
      edit: { featureGroup: drawnItems, remove: true, poly: { allowIntersection: false } },
      draw: { polyline: { shapeOptions: { color: '#dc2626', weight: 6, opacity: 0.9 } },
              polygon: false, rectangle: false, circle: false, marker: false, circlemarker: false }
    });
    map.addControl(drawControl);

    // === GPX-verktyg (Open / TRK / Trash) ===
    let trkButtonRef = null;
    const GPXControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function () {
        const toolbar = L.DomUtil.create('div', 'gpx-toolbar leaflet-draw-toolbar leaflet-bar');
        L.DomEvent.disableClickPropagation(toolbar);

        // Open
        const openA = L.DomUtil.create('a', 'gpx-btn', toolbar);
        openA.textContent = 'Open';
        const fileInput = L.DomUtil.create('input', '', toolbar);
        fileInput.type = 'file';
        fileInput.accept = '.gpx,application/gpx+xml,application/xml,text/xml';
        fileInput.style.display = 'none';
        openA.onclick = (e) => { e.preventDefault(); fileInput.click(); };
        fileInput.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => { loadGPXFromText(evt.target.result, file.name); };
          reader.readAsText(file);
        };

        // TRK
        const listA = L.DomUtil.create('a', 'gpx-btn', toolbar);
        listA.textContent = 'TRK';
        listA.onclick = (e) => { e.preventDefault(); toggleListPanel(listA); };
        trkButtonRef = listA;

        // Trash
        const clearA = L.DomUtil.create('a', 'leaflet-draw-edit-remove', toolbar);
        clearA.title = 'Rensa GPX';
        clearA.onclick = (e) => { e.preventDefault(); clearGpxTrack(); };

        return toolbar;
      }
    });
    map.addControl(new GPXControl());

    // === GPS-knapp ===
    const LocateControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function () {
        const div = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');
        const btn = L.DomUtil.create('a', 'gps-btn', div);
        btn.textContent = 'GPS';
        btn.href = '#';
        btn.title = 'Följ min position';
        btn.onclick = (e) => { e.preventDefault(); toggleGPS(btn); };
        return div;
      }
    });
    map.addControl(new LocateControl());

    // === Rotator-knapp ===
    const RotatorControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function () {
        const div = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');
        const btn = L.DomUtil.create('a', 'rot-btn', div);
        btn.textContent = 'ROT';
        btn.href = '#';
        btn.title = 'Rotatorläge (karta roterar, pil pekar upp, position i mitten)';
        btn.onclick = (e) => { e.preventDefault(); toggleRotator(btn); };
        return div;
      }
    });
    map.addControl(new RotatorControl());

    // === Distans + export ===
    const distanceOutput = document.getElementById('distance-output');
    const exportBtn = document.getElementById('export-btn');
    let drawnRouteLayer = null, gpxTrackLayer = null;

    function setDistanceKm(km) { distanceOutput.textContent = `${km.toFixed(2)} km`; }
    function computeLengthKmFromLatLngs(latlngs) {
      if (!latlngs || latlngs.length < 2) return 0;
      const line = L.polyline(latlngs).toGeoJSON();
      return turf.length(line, { units: 'kilometers' });
    }
    function updateExportState() {
      const ok = !!(drawnRouteLayer && drawnRouteLayer.getLatLngs().length >= 2);
      exportBtn.disabled = !ok;
      exportBtn.onclick = ok ? () => exportToGPX(drawnRouteLayer.getLatLngs()) : null;
    }

    map.on(L.Draw.Event.DRAWSTART, (e) => {
      if (e.layerType === 'polyline') { setDistanceKm(0); exportBtn.disabled = true; exportBtn.onclick = null; }
    });
    map.on(L.Draw.Event.DRAWVERTEX, (e) => {
      const latlngs = []; e.layers.eachLayer((m) => latlngs.push(m.getLatLng()));
      setDistanceKm(computeLengthKmFromLatLngs(latlngs));
    });
    map.on(L.Draw.Event.CREATED, (e) => {
      if (e.layerType === 'polyline') {
        if (drawnRouteLayer) drawnItems.removeLayer(drawnRouteLayer);
        drawnRouteLayer = e.layer; drawnItems.addLayer(drawnRouteLayer);
        setDistanceKm(computeLengthKmFromLatLngs(drawnRouteLayer.getLatLngs()));
        updateExportState();
      }
    });
    map.on(L.Draw.Event.EDITVERTEX, () => {
      if (drawnRouteLayer) { setDistanceKm(computeLengthKmFromLatLngs(drawnRouteLayer.getLatLngs())); updateExportState(); }
    });
    map.on(L.Draw.Event.EDITED, () => {
      if (drawnRouteLayer) { setDistanceKm(computeLengthKmFromLatLngs(drawnRouteLayer.getLatLngs())); updateExportState(); }
    });

    // === Export: GPX 1.1 (RTE + TRK) ===
    function exportToGPX(latlngs) {
      if (!latlngs || latlngs.length < 2) return;

      const now = new Date();
      const isoNow = now.toISOString().split('.')[0] + 'Z';
      const routeName = `Rutt_${new Date().toLocaleDateString('sv-SE')}_`
        + new Date().toLocaleTimeString('sv-SE', { hour12: false }).replace(/:/g, '-');

      let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1"
     creator="Ruttplan"
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1
                         http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata><name>${routeName}</name><time>${isoNow}</time></metadata>
  <rte><name>${routeName}</name><time>${isoNow}</time>`;
      latlngs.forEach((p,i)=>{ gpx += `\n    <rtept lat="${p.lat.toFixed(6)}" lon="${p.lng.toFixed(6)}"><name>P${i+1}</name></rtept>`; });
      gpx += `
  </rte>
  <trk><name>${routeName}</name><trkseg>`;
      latlngs.forEach((p,i)=> {
        const t = new Date(now.getTime() + i*1000).toISOString().split('.')[0] + 'Z';
        gpx += `\n    <trkpt lat="${p.lat.toFixed(6)}" lon="${p.lng.toFixed(6)}"><time>${t}</time></trkpt>`;
      });
      gpx += `
    </trkseg></trk>
</gpx>`;
      const blob = new Blob([gpx], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = routeName.replace(/ /g,'_')+'.gpx';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function attachGPXLayer(layer) {
      if (gpxTrackLayer) map.removeLayer(gpxTrackLayer);
      gpxTrackLayer = layer.addTo(map);
      layer.on('loaded', e => {
        map.fitBounds(e.target.getBounds());
        const len = turf.length(e.target.toGeoJSON(), { units: 'kilometers' });
        setDistanceKm(len);
      });
    }
    function loadGPXFromText(text) { attachGPXLayer(new L.GPX(text, { async: true })); }
    function loadGPXFromURL(url) { attachGPXLayer(new L.GPX(url, { async: true })); }
    function clearGpxTrack() {
      if (gpxTrackLayer) map.removeLayer(gpxTrackLayer);
      gpxTrackLayer = null;
      if (!drawnRouteLayer) setDistanceKm(0);
      updateExportState();
    }

    // === Fördefinierade GPX-listan ===
    const panel = document.getElementById('gpxListPanel');
    const listEl = document.getElementById('gpxList');
    const emptyEl = document.getElementById('gpxListEmpty');
    let loaded = false;
    let outsideClickHandler = null;

    function toggleListPanel(anchorEl) {
      if (panel.classList.contains('open')) { closeListPanel(); return; }
      positionPanelNextTo(anchorEl);
      if (!loaded) loadTracksList();
      panel.classList.add('open');
      outsideClickHandler = (ev) => {
        if (panel.contains(ev.target) || (anchorEl && anchorEl.contains(ev.target))) return;
        closeListPanel();
      };
      document.addEventListener('click', outsideClickHandler);
    }
    function closeListPanel() {
      panel.classList.remove('open');
      if (outsideClickHandler) {
        document.removeEventListener('click', outsideClickHandler);
        outsideClickHandler = null;
      }
    }
    function positionPanelNextTo(anchorEl) {
      if (!anchorEl) return;
      const mapRect = map.getContainer().getBoundingClientRect();
      const r = anchorEl.getBoundingClientRect();
      const top = r.top - mapRect.top;
      const left = r.right - mapRect.left + 8;
      panel.style.top = `${top}px`;
      panel.style.left = `${left}px`;
    }
    async function loadTracksList() {
      loaded = true;
      listEl.innerHTML = '';
      emptyEl.classList.add('hidden');
      try {
        const res = await fetch('gpx-tracks/manifest.json');
        const files = await res.json();
        if (!Array.isArray(files) || files.length === 0) {
          emptyEl.classList.remove('hidden');
          return;
        }
        for (const file of files) {
          const url = `gpx-tracks/${file}`;
          const item = document.createElement('div');
          item.className = 'gpx-list-item';
          item.textContent = file;
          item.onclick = () => { loadGPXFromURL(url); closeListPanel(); };
          listEl.appendChild(item);
        }
      } catch {
        emptyEl.classList.remove('hidden');
      }
    }
    window.addEventListener('resize', () => {
      if (panel.classList.contains('open') && trkButtonRef) positionPanelNextTo(trkButtonRef);
    });

    // =======================
    // ===== GPS & Heading ===
    // =======================
    let watchId = null;
    let following = false;
    let rotatorOn = false;

    let headingDeg = null;
    let headingAccuracyDeg = null; // iOS: webkitCompassAccuracy
    let orientationActive = false;

    // Smoothing för heading (används för kartrotation; pilen kan vara fast)
    let smoothHeading = 0;
    const HEADING_ALPHA = HEADING_SMOOTH;
    let needFrame = false;

    // Skapa egen rotator-wrapper och flytta in tile+overlay dit
    const mapPane = map.getPane('mapPane');
    const tilePane = map.getPane('tilePane');
    const overlayPane = map.getPane('overlayPane');
    const rotator = document.createElement('div');
    rotator.className = 'bearing-rotator';
    mapPane.appendChild(rotator);
    rotator.appendChild(tilePane);
    rotator.appendChild(overlayPane);

    // Position marker & accuracy
    function makeHeadingIcon() {
      return L.divIcon({
        className: 'heading-marker heading-unknown',
        html: `
          <div class="arrow-wrap">
            <svg class="arrow-svg" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
              <path class="fan" fill="${FAN_FILL}" fill-opacity="${FAN_OPACITY}" d="" />
              <path d="M32 6 L42 28 L34 24 L34 56 L30 56 L30 24 L22 28 Z" fill="rgba(0,0,0,0.25)"/>
              <path d="M32 6 L42 28 L34 24 L34 56 L30 56 L30 24 L22 28 Z" fill="#111827"/>
            </svg>
          </div>
          <div class="dot"></div>
        `,
        iconSize: [28,28],
        iconAnchor: [14,14]
      });
    }
    let posMarker = null;
    let accCircle = null;

    function toggleGPS(btn) {
      following = !following;
      btn.classList.toggle('gps-active', following);
      if (following) {
        startGeolocation();
        ensureOrientation(); // behövs både för pil och rotator
      } else {
        stopGeolocation();
        if (!rotatorOn) disableOrientation();
      }
    }

    function startGeolocation() {
      if (!navigator.geolocation) return alert('Geolocation stöds inte i denna webbläsare.');
      watchId = navigator.geolocation.watchPosition(onPosition, onPositionError, {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      });
    }
    function stopGeolocation() {
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
    }
    function onPosition(pos) {
      const { latitude, longitude, accuracy } = pos.coords;
      const ll = [latitude, longitude];

      if (!posMarker) {
        posMarker = L.marker(ll, { icon: makeHeadingIcon(), interactive: false }).addTo(map);
      } else {
        posMarker.setLatLng(ll);
      }
      if (!accCircle) {
        accCircle = L.circle(ll, { radius: accuracy, color: '#3b82f6', weight: 1, fillColor: '#60a5fa', fillOpacity: 0.15, interactive: false }).addTo(map);
      } else {
        accCircle.setLatLng(ll).setRadius(accuracy);
      }

      if (rotatorOn) {
        // håll position i mitten – ingen animation för att undvika driv/lagg
        map.setView(ll, map.getZoom(), { animate: false });
      } else if (following) {
        map.setView(ll, Math.max(map.getZoom(), 15), { animate: true });
      }

      queueFrame();
    }
    function onPositionError(err) { console.warn('Geolocation error:', err); }

    // ====== DeviceOrientation (kompass) ======
    function ensureOrientation() {
      const needIOSPermission = typeof DeviceOrientationEvent !== 'undefined' &&
                                typeof DeviceOrientationEvent.requestPermission === 'function';
      if (needIOSPermission) {
        DeviceOrientationEvent.requestPermission().then(state => {
          if (state === 'granted') startOrientation();
        }).catch(() => {/* ignorerad */});
      } else {
        startOrientation();
      }
    }
    function startOrientation() {
      if (orientationActive) return;
      orientationActive = true;
      window.addEventListener('deviceorientation', onOrientation, true);
      window.addEventListener('deviceorientationabsolute', onOrientation, true);
    }
    function disableOrientation() {
      orientationActive = false;
      // (lämna listeners – låg kostnad, men kan tas bort om du vill)
    }

    function onOrientation(e) {
      const screenAngle = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : 0;

      if (typeof e.webkitCompassHeading === 'number') {
        // iOS
        headingDeg = normalizeDeg(e.webkitCompassHeading);
        headingAccuracyDeg = (typeof e.webkitCompassAccuracy === 'number' && isFinite(e.webkitCompassAccuracy))
            ? Math.max(0, Math.min(180, e.webkitCompassAccuracy))
            : null;
      } else if (typeof e.alpha === 'number') {
        // Android/Chrome
        const alpha = e.alpha;
        let h = 360 - alpha;       // 0=norr, medurs
        h = h - screenAngle;       // kompensera skärmvinkel
        headingDeg = normalizeDeg(h);
        headingAccuracyDeg = null;
      } else {
        headingDeg = null;
      }
      queueFrame();
    }

    function normalizeDeg(a) { a = a % 360; if (a < 0) a += 360; return a; }
    function shortestDelta(a,b){ let d = (b - a + 540) % 360 - 180; return d; }
    function smoothTowards(current, target, k){
      const d = shortestDelta(current, target);
      return normalizeDeg(current + d * k);
    }

    // === Fan-path beräkning ===
    function fanPathD(fanDeg) {
      const cx = 32, cy = 32, r = 28; // center + radie i 64x64
      const half = fanDeg / 2;
      const start = (-90 - half) * Math.PI / 180;
      const end   = (-90 + half) * Math.PI / 180;
      const x1 = cx + r * Math.cos(start);
      const y1 = cy + r * Math.sin(start);
      const x2 = cx + r * Math.cos(end);
      const y2 = cy + r * Math.sin(end);
      const largeArc = (fanDeg > 180) ? 1 : 0;
      return `M ${cx} ${cy} L ${x1.toFixed(2)} ${y1.toFixed(2)} A ${r} ${r} 0 ${largeArc} 1 ${x2.toFixed(2)} ${y2.toFixed(2)} Z`;
    }
    function currentFanDeg() {
      if (headingAccuracyDeg != null) {
        return Math.max(MIN_FAN_DEG, Math.min(MAX_FAN_DEG, headingAccuracyDeg * 2));
      }
      return DEFAULT_FAN_DEG;
    }

    // === rAF-uppdatering (pilen + rotator) ===
    function queueFrame(){
      if (needFrame) return;
      needFrame = true;
      requestAnimationFrame(tick);
    }
    function tick(){
      needFrame = false;
      updateMarkerAndRotation();
    }

    function updateMarkerAndRotation() {
      // Uppdatera pil + fan
      if (posMarker) {
        const el = posMarker.getElement();
        if (el) {
          const wrap = el.querySelector('.arrow-wrap');
          const fanPath = el.querySelector('.fan');
          if (wrap && fanPath) {
            // Sätt pilens rotation:
            // - Rotator PÅ: pilen SKA peka uppåt => 0°
            // - Rotator AV: pilen följer heading mjukt
            if (headingDeg == null) {
              el.classList.add('heading-unknown');
              smoothHeading = smoothTowards(smoothHeading, 0, HEADING_ALPHA);
            } else {
              el.classList.remove('heading-unknown');
              const target = rotatorOn ? 0 : headingDeg;
              smoothHeading = smoothTowards(smoothHeading, target, HEADING_ALPHA);
            }
            wrap.style.transform = `rotate(${smoothHeading}deg)`;

            // Fan-bredd utifrån accuracy
            const fanDeg = currentFanDeg();
            fanPath.setAttribute('d', fanPathD(fanDeg));
          }
        }
      }

      // Rotera karta om rotator är på
      if (rotatorOn) {
        const targetBearing = (headingDeg == null) ? 0 : -headingDeg; // karta motsols
        const newBearing = smoothTowards(getCurrentRotDeg(), targetBearing, HEADING_ALPHA);
        rotator.style.transform = `translateZ(0) rotate(${newBearing}deg) scale(${ROT_SCALE})`;
        rotator.setAttribute('data-rot', newBearing.toFixed(3));
      }
    }
    function getCurrentRotDeg(){
      const v = rotator.getAttribute('data-rot');
      return v ? parseFloat(v) : 0;
    }

    // === Rotatorläge on/off ===
    function toggleRotator(btn){
      rotatorOn = !rotatorOn;
      btn.classList.toggle('rot-active', rotatorOn);
      if (rotatorOn) {
        // se till att vi har sensorer och följer användaren
        if (!following) {
          following = true;
          // markera GPS-knappen om du vill – hoppa det visuella om du inte har dess ref
          startGeolocation();
        }
        ensureOrientation();
        // nollställ rotation
        rotator.style.transform = `translateZ(0) rotate(0deg) scale(${ROT_SCALE})`;
        rotator.setAttribute('data-rot', '0');
        queueFrame();
      } else {
        // återställ
        rotator.style.transform = 'translateZ(0) rotate(0deg) scale(1)';
        rotator.removeAttribute('data-rot');
        // pilen återgår till att visa heading i tick()
        if (!following) disableOrientation();
      }
    }

    // === Init ===
    updateExportState();
  });
  </script>
</body>
</html>
